<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十大经典排序算法(Java)</title>
      <link href="/2020/07/21/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(Java)/"/>
      <url>/2020/07/21/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(Java)/</url>
      
        <content type="html"><![CDATA[<h3 id="1-排序算法说明"><a href="#1-排序算法说明" class="headerlink" title="1.排序算法说明"></a>1.排序算法说明</h3><h4 id="1-1-排序的定义"><a href="#1-1-排序的定义" class="headerlink" title="1.1 排序的定义"></a>1.1 排序的定义</h4><p>对一序列对象根据某个关键字进行排序。本文对十大排序算法进行解读。</p><h4 id="1-2-术语说明"><a href="#1-2-术语说明" class="headerlink" title="1.2 术语说明"></a>1.2 术语说明</h4><ul><li><strong>稳定</strong>：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li><li><strong>不稳定</strong>：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li></ul><h4 id="1-3-算法总结"><a href="#1-3-算法总结" class="headerlink" title="1.3 算法总结"></a>1.3 算法总结</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015233043168-1867817869.png" alt=""></p><p><strong>图片名词解释：</strong></p><ul><li>n: 数据规模</li><li>k: “桶” 的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><h4 id="1-4-算法分类"><a href="#1-4-算法分类" class="headerlink" title="1.4 算法分类"></a>1.4 算法分类</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015233220637-1055088118.png" alt=""></p><h4 id="1-5-比较和非比较的区别"><a href="#1-5-比较和非比较的区别" class="headerlink" title="1.5 比较和非比较的区别"></a>1.5 比较和非比较的区别</h4><p>常见的<strong>快速排序、归并排序、堆排序、冒泡排序</strong>等属于<strong>比较排序</strong>。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong><br>在<strong>冒泡排序</strong>之类的排序中，问题规模为 n，又因为需要比较 n 次，所以平均时间复杂度为 O(n²)。在<strong>归并排序、快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 logN 次，所以时间复杂度平均 <strong>O(nlogn)</strong>。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，<strong>比较排序适用于一切需要排序的情况。</strong></p><p><strong>计数排序、基数排序、桶排序</strong>则属于<strong>非比较排序</strong>。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组 arr，计算 arr[i] 之前有多少个元素，则唯一确定了 arr[i] 在排序后数组中的位置。<br>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 <strong>O(n)</strong>。<br><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p><h3 id="2-冒泡排序（Bubble-Sort）"><a href="#2-冒泡排序（Bubble-Sort）" class="headerlink" title="2.冒泡排序（Bubble Sort）"></a>2.冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。 </p><h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤 1~3，直到排序完成。</li></ul><h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a>2.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt=""></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><pre><code>   　　/**        * 冒泡排序        *        * @param array        * @return        */       public static int[] bubbleSort(int[] array) {           if (array == null || array.length == 0) {               return array;           }           // 外层：length-1次循环           for (int i = 0; i &lt; array.length - 1; i++) {               for (int j = 0; j &lt; array.length - 1 - i; j++) {                   // 将较小的与大的交换位置                   if (array[j + 1] &lt; array[j]) {                       // 采用临时变量法交换                       int temp = array[j + 1];                       array[j + 1] = array[j];                       array[j] = temp;                   }                }             }             return array;         }</code></pre><h4 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h4><p>冒泡排序是稳定的排序算法，最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为<strong>O(n²)</strong>. 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为<strong>O(n)</strong>. 平均来讲, 时间复杂度为<strong>O(n²)</strong>. 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此<strong>空间复杂度为常量O(1)</strong>。</p><h3 id="3-选择排序（Selection-Sort）"><a href="#3-选择排序（Selection-Sort）" class="headerlink" title="3.选择排序（Selection Sort）"></a>3.选择排序（Selection Sort）</h3><p><strong>无论什么数据进去都是 O(n^2) 的时间复杂度</strong>，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><p>选择排序 (Selection-sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为 R[1..n]，有序区为空；</li><li>第 i 趟排序 (i=1,2,3…n-1) 开始时，当前有序区和无序区分别为 R[1..i-1]和 R(i..n）。该趟排序从当前无序区中 - 选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i]和 R[i+1..n)分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；</li><li>n-1 趟结束，数组有序化了。</li></ul><h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="">　　</p><h4 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h4><pre><code>　　/**     * 选择排序     * @param array     * @return     */    public static int[] selectionSort(int[] array) {        if (array.length == 0) {            return array;        }        for (int i = 0; i &lt; array.length - 1; i++) {            int minIndex = i;            for (int j = i + 1; j &lt; array.length; j++) {                if (array[j] &lt; array[minIndex]) //找到最小的数                    minIndex = j; //将最小数的索引保存            }            if (minIndex != i) {                int temp = array[minIndex];                array[minIndex] = array[i];                array[i] = temp;            }        }        return array;    }</code></pre><h4 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h4><p><strong>最佳情况：O(n^2)  最差情况：O(n^2)  平均情况： O(n^2)</strong></p><h3 id="4-插入排序（Insertion-Sort）"><a href="#4-插入排序（Insertion-Sort）" class="headerlink" title="4.插入排序（Insertion Sort）"></a>4.插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2~5。</li></ul><h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt=""></p><h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><p>提供两种写法，一种是移位法，一种是交换法。移位法是完全按照以上算法描述实，再插入过程中将有序序列中比待插入数字大的数据向后移动，由于移动时会覆盖待插入数据，所以需要额外的临时变量保存待插入数据，代码实现如下：</p><pre><code>　　/**     * 插入排序-移位法     * @param array     * @return     */    public static int[] insertionSort(int[] arr) {        if (arr == null || arr.length == 0) {            return arr;        }        for (int i = 0; i &lt; arr.length; i++) {            int j = i - 1;            int temp = a[i]; // 先取出待插入数据保存，因为向后移位过程中会把覆盖掉待插入数            // 如果待是比待插入数据大，就后移            while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) {                arr[j + 1] = arr[j];                j--;            }            // 找到比待插入数据小的位置，将待插入数据插入            arr[j + 1] = temp;        }        return arr;    }</code></pre><p>而交换法不需求额外的保存待插入数据，通过不停的向前交换带插入数据，类似冒泡法，直到找到比它小的值，也就是待插入数据找到了自己的位置:</p><pre><code>    public static void insertionSort(int[] arr) {        if (arr == null || arr.length == 0) {            return;        }        for (int i = 1; i &lt; arr.length; i++) {            int j = i - 1;             while (j &gt;= 0 &amp;&amp; arr[j] &gt; arr[i]) {                arr[j + 1] = arr[j] + arr[j+1];      //只要大就交换操作                arr[j] = arr[j + 1] - arr[j];                arr[j + 1] = arr[j + 1] - arr[j];                System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));             }        }    }</code></pre><h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 <strong>算法分析</strong></h4><p><strong>最佳情况： O(n)   最坏情况： O(n^2)   平均情况： O(n^2)    空间复杂度：O(1)</strong></p><h3 id="5-希尔排序（Shell-Sort）"><a href="#5-希尔排序（Shell-Sort）" class="headerlink" title="5.希尔排序（Shell Sort）"></a>5.希尔排序（Shell Sort）</h3><p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为<strong>缩小增量排序</strong>，同时该算法是冲破 O(n2）的第一批算法之一。它与插入排序的不同之处在于，<strong>它会优先比较距离较远的元素</strong>; 直接插入排序是稳定的；而希尔排序是不稳定的。希尔排序又叫缩小增量排序。</p><p>希尔排序是把记录按一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p><h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量 gap=length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示，<strong>{n/2,(n/2)/2…1}</strong>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="5-2-过程演示"><a href="#5-2-过程演示" class="headerlink" title="5.2 过程演示"></a>5.2 过程演示</h4><p><img src="https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180319094116040-1638766271.png" alt=""></p><h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><pre><code>　　/**     * 希尔排序     *     * @param array     * @return     */    public static int[] ShellSort(int[] array) {        int len = array.length;        int temp, gap = len / 2;        while (gap &gt; 0) {            for (int i = gap; i &lt; len; i++) {                temp = array[i];                int preIndex = i - gap;                while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) {                    array[preIndex + gap] = array[preIndex];                    preIndex -= gap;                }                array[preIndex + gap] = temp;            }            gap /= 2;        }        return array;    }</code></pre><h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>*<em>最佳情况： O(nlog n)  最坏情况： O(nlog n)  平均情况：O(nlog n)　*</em></p><h3 id="6-归并排序（Merge-Sort）"><a href="#6-归并排序（Merge-Sort）" class="headerlink" title="6.归并排序（Merge Sort）"></a>6.归并排序（Merge Sort）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。 </p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><ul><li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt=""></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><pre><code>　　/**     * 归并排序     *     * @param array     * @return     */    public static int[] MergeSort(int[] array) {        if (array.length &lt; 2) return array;        int mid = array.length / 2;        int[] left = Arrays.copyOfRange(array, 0, mid);        int[] right = Arrays.copyOfRange(array, mid, array.length);        return merge(MergeSort(left), MergeSort(right));    }    /**     * 归并排序——将两段排序好的数组结合成一个排序数组     *     * @param left     * @param right     * @return     */    public static int[] merge(int[] left, int[] right) {        int[] result = new int[left.length + right.length];        for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {            if (i &gt;= left.length)                result[index] = right[j++];            else if (j &gt;= right.length)                result[index] = left[i++];            else if (left[i] &gt; right[j])                result[index] = right[j++];            else                result[index] = left[i++];        }        return result;    }</code></pre><h4 id="6-4-算法分析"><a href="#6-4-算法分析" class="headerlink" title="6.4 算法分析"></a>6.4 算法分析</h4><p><strong>最佳情况：O(nlog n)  最差情况：O(nlog n)  平均情况： O(nlog n)    空间复杂度：O(n)</strong></p><h3 id="7-快速排序（Quick-Sort）"><a href="#7-快速排序（Quick-Sort）" class="headerlink" title="7.快速排序（Quick Sort）"></a>7.快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录<strong>继续进行快速排序</strong>，以达到整个序列有序。</p><h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><p>快速排序使用<strong>分治法</strong>来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong>）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt=""></p><h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><pre><code>　　/**     * 快速排序方法（左右指针法）     * @param array     * @param start     * @param end     * @return     */    public static int[] QuickSort(int[] array, int start, int end) {        if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) {            return null;        }        int smallIndex = partition(array, start, end);        if (smallIndex &gt; start)            QuickSort(array, start, smallIndex - 1);        if (smallIndex &lt; end)            QuickSort(array, smallIndex + 1, end);        return array;    }    /**     * 快速排序算法——partition     * @param array     * @param start     * @param end     * @return     */    public static int partition(int[] array, int start, int end) {        int pivot = (int) (start + Math.random() * (end - start + 1));        int smallIndex = start - 1;        swap(array, pivot, end);        for (int i = start; i &lt;= end; i++)            if (array[i] &lt;= array[end]) {                smallIndex++;                if (i &gt; smallIndex)                    swap(array, i, smallIndex);            }        return smallIndex;    }    /**     * 交换数组内两个元素     * @param array     * @param i     * @param j     */    public static void swap(int[] array, int i, int j) {        int temp = array[i];        array[i] = array[j];        array[j] = temp;    }</code></pre><h4 id="7-4-算法分析"><a href="#7-4-算法分析" class="headerlink" title="7.4 算法分析"></a>7.4 算法分析</h4><p><strong>最佳情况： O(nlog n)   最差情况： O(n^2)   平均情况： O(nlog n)　空间复杂度：O(1)</strong></p><h3 id="8-堆排序（Heap-Sort）"><a href="#8-堆排序（Heap-Sort）" class="headerlink" title="8.堆排序（Heap Sort）"></a>8.堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul><li>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素 R[1]与最后一个元素 R[n]交换，此时得到新的无序区 (R1,R2,……Rn-1) 和新的有序区(Rn), 且满足 R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶 R[1]可能违反堆的性质，因此需要对当前无序区 (R1,R2,……Rn-1) 调整为新堆，然后再次将 R[1]与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。</li></ul><h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif" alt=""></p><h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><p>注意：这里用到了完全二叉树的部分性质：详情见<a href="http://www.cnblogs.com/guoyaohua/p/8595289.html" target="_blank" rel="noopener">《数据结构二叉树知识点总结》</a></p><pre><code>//声明全局变量，用于记录数组array的长度；static int len;    /**     * 堆排序算法     *     * @param array     * @return     */    public static int[] HeapSort(int[] array) {        len = array.length;        if (len &lt; 1) return array;        //1.构建一个最大堆        buildMaxHeap(array);        //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆        while (len &gt; 0) {            swap(array, 0, len - 1);            len--;            adjustHeap(array, 0);        }        return array;    }    /**     * 建立最大堆     *     * @param array     */    public static void buildMaxHeap(int[] array) {        //从最后一个非叶子节点开始向上构造最大堆        for (int i = (len/2 - 1); i &gt;= 0; i--) { //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1)             adjustHeap(array, i);        }    }    /**     * 调整使之成为最大堆     *     * @param array     * @param i     */    public static void adjustHeap(int[] array, int i) {        int maxIndex = i;        //如果有左子树，且左子树大于父节点，则将最大指针指向左子树        if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex])            maxIndex = i * 2;        //如果有右子树，且右子树大于父节点，则将最大指针指向右子树        if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex])            maxIndex = i * 2 + 1;        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。        if (maxIndex != i) {            swap(array, maxIndex, i);            adjustHeap(array, maxIndex);        }    }</code></pre><h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p><strong>最佳情况： O(nlogn) 最差情况： O(nlogn) 平均情况： O(nlogn)    空间复杂度：O(1)</strong></p><h3 id="9-计数排序（Counting-Sort）"><a href="#9-计数排序（Counting-Sort）" class="headerlink" title="9.计数排序（Counting Sort）"></a>9.计数排序（Counting Sort）</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。</p><h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li><li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</li></ul><h4 id="9-2-动图演示"><a href="#9-2-动图演示" class="headerlink" title="9.2 动图演示"></a>9.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif" alt=""></p><h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><pre><code>/**     * 计数排序     *     * @param array     * @return     */    public static int[] CountingSort(int[] array) {        if (array.length == 0) return array;        int bias, min = array[0], max = array[0];        for (int i = 1; i &lt; array.length; i++) {            if (array[i] &gt; max)                max = array[i];            if (array[i] &lt; min)                min = array[i];        }        bias = 0 - min;        int[] bucket = new int[max - min + 1];        Arrays.fill(bucket, 0);        for (int i = 0; i &lt; array.length; i++) {            bucket[array[i] + bias]++;        }        int index = 0, i = 0;        while (index &lt; array.length) {            if (bucket[i] != 0) {                array[index] = i - bias;                bucket[i]--;                index++;            } else                i++;        }        return array;    }</code></pre><h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><p><strong>最佳情况： O(n+k)  最差情况： O(n+k)  平均情况： O(n+k)</strong></p><h3 id="10-桶排序（Bucket-Sort）"><a href="#10-桶排序（Bucket-Sort）" class="headerlink" title="10.桶排序（Bucket Sort）"></a>10.桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort) 的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul><li>人为设置一个 BucketSize，作为每个桶所能放置多少个不同数值（例如当 BucketSize==5 时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放 100 个 3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为 1 时要手动减小 BucketSize 增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p><h4 id="10-2-图片演示"><a href="#10-2-图片演示" class="headerlink" title="10.2 图片演示"></a>10.2 图片演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png" alt=""></p><h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><pre><code>    /**     * 桶排序     *      * @param array     * @param bucketSize     * @return     */    public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) {        if (array == null || array.size() &lt; 2)            return array;        int max = array.get(0), min = array.get(0);        // 找到最大值最小值        for (int i = 0; i &lt; array.size(); i++) {            if (array.get(i) &gt; max)                max = array.get(i);            if (array.get(i) &lt; min)                min = array.get(i);        }        int bucketCount = (max - min) / bucketSize + 1;        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);        ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; bucketCount; i++) {            bucketArr.add(new ArrayList&lt;Integer&gt;());        }        for (int i = 0; i &lt; array.size(); i++) {            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));        }        for (int i = 0; i &lt; bucketCount; i++) {            if (bucketSize == 1) { // 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误                for (int j = 0; j &lt; bucketArr.get(i).size(); j++)                    resultArr.add(bucketArr.get(i).get(j));            } else {                if (bucketCount == 1)                    bucketSize--;                ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);                for (int j = 0; j &lt; temp.size(); j++)                    resultArr.add(temp.get(j));            }        }        return resultArr;    }</code></pre><h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><p>*<em>最佳情况： O(n+k)   最差情况： O(n+k)   平均情况： O(n^2)　　*</em></p><h3 id="11-基数排序（Radix-Sort）"><a href="#11-基数排序（Radix-Sort）" class="headerlink" title="11.基数排序（Radix Sort）"></a>11.基数排序（Radix Sort）</h3><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为 O(kn), 为数组长度，k 为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="11-1-算法描述"><a href="#11-1-算法描述" class="headerlink" title="11.1 算法描述"></a>11.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr 为原始数组，从最低位开始取每个位组成 radix 数组；</li><li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="11-2-动图演示"><a href="#11-2-动图演示" class="headerlink" title="11.2 动图演示"></a>11.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif" alt=""> </p><h4 id="11-3-代码实现"><a href="#11-3-代码实现" class="headerlink" title="11.3 代码实现"></a>11.3 代码实现</h4><pre><code>　　/**     * 基数排序     * @param array     * @return     */    public static int[] RadixSort(int[] array) {        if (array == null || array.length &lt; 2)            return array;        // 1.先算出最大数的位数；        int max = array[0];        for (int i = 1; i &lt; array.length; i++) {            max = Math.max(max, array[i]);        }        int maxDigit = 0;        while (max != 0) {            max /= 10;            maxDigit++;        }        int mod = 10, div = 1;        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();        for (int i = 0; i &lt; 10; i++)            bucketList.add(new ArrayList&lt;Integer&gt;());        for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) {            for (int j = 0; j &lt; array.length; j++) {                int num = (array[j] % mod) / div;                bucketList.get(num).add(array[j]);            }            int index = 0;            for (int j = 0; j &lt; bucketList.size(); j++) {                for (int k = 0; k &lt; bucketList.get(j).size(); k++)                    array[index++] = bucketList.get(j).get(k);                bucketList.get(j).clear();            }        }        return array;    }</code></pre><h4 id="11-4-算法分析"><a href="#11-4-算法分析" class="headerlink" title="11.4 算法分析"></a>11.4 算法分析</h4><p><strong>最佳情况：O(n * k)   最差情况：O(n * k)   平均情况：O(n * k)    空间复杂度: O(n+k)</strong></p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序 LSD 从低位开始进行排序 </p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://juejin.im/post/5b95da8a5188255c775d8124" target="_blank" rel="noopener">https://juejin.im/post/5b95da8a5188255c775d8124</a></p><p><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></p><p><a href="https://www.cnblogs.com/Young111/p/11300929.html" target="_blank" rel="noopener">https://www.cnblogs.com/Young111/p/11300929.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射、注解和动态代理</title>
      <link href="/2020/07/20/%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2020/07/20/%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p> <a href="(https://www.cnblogs.com/younghao/p/9751566.html)">原文地址</a> </p></blockquote><h3 id="一、Java-反射机制及基本用法"><a href="#一、Java-反射机制及基本用法" class="headerlink" title="一、Java 反射机制及基本用法"></a>一、Java 反射机制及基本用法</h3><p>反射是指计算机程序在<strong>运行时</strong>访问、检测和修改它本身状态或行为的一种能力，是一种元编程语言特性，有很多语言都提供了对反射机制的支持，它使程序能够编写程序。Java 的反射机制使得 Java 能够动态的获取类的信息和调用对象的方法。</p><p>在 Java 中，Class（类类型）是反射编程的起点，代表运行时类型信息（RTTI，Run-Time Type Identification）。java.lang.reflect 包含了 Java 支持反射的主要组件，如 Constructor、Method 和 Field 等，分别表示类的构造器、方法和域，它们的关系如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/3923557-fadce88e244acb57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>Constructor 和 Method 与 Field 的区别在于前者继承自抽象类 Executable，是可以在运行时动态调用的，而 Field 仅仅具备可访问的特性，且默认为不可访问。下面了解下它们的基本用法：</p><p><img src="https://upload-images.jianshu.io/upload_images/3923557-711bcb9dbdec0b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/860" alt=""></p><ul><li>获取 Class 对象有三种方式，Class.forName 适合于已知类的全路径名，典型应用如加载 JDBC 驱动。对同一个类，不同方式获得的 Class 对象是相同的。</li></ul><pre><code>// 1. 采用Class.forName获取类的Class对象Class clazz0 = Class.forName(&quot;com.yhthu.java.ClassTest&quot;);System.out.println(&quot;clazz0:&quot; + clazz0);// 2. 采用.class方法获取类的Class对象Class clazz1 = ClassTest.class;System.out.println(&quot;clazz1:&quot; + clazz1);// 3. 采用getClass方法获取类的Class对象ClassTest classTest = new ClassTest();Class clazz2 = classTest.getClass();System.out.println(&quot;clazz2:&quot; + clazz2);// 4. 判断Class对象是否相同System.out.println(&quot;Class对象是否相同:&quot; + ((clazz0.equals(clazz1)) &amp;&amp; (clazz1.equals(clazz2))));</code></pre><blockquote><p>注意：三种方式获取的 Class 对象相同的前提是使用了相同的类加载器，比如上述代码中默认采用应用程序类加载器（sun.misc.Launcher$AppClassLoader）。不同类加载器加载的同一个类，也会获取不同的 Class 对象：</p></blockquote><pre><code>// 自定义类加载器ClassLoader myLoader = new ClassLoader() {    @Override    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {        try {            String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;            InputStream is = getClass().getResourceAsStream(fileName);            if (is == null) {                return super.loadClass(name);            }            byte[] b = new byte[is.available()];            is.read(b);            return defineClass(name, b, 0, b.length);        } catch (IOException e) {            throw new ClassNotFoundException(name);        }    }};// 采用自定义类加载器加载Class clazz3 = Class.forName(&quot;com.yhthu.java.ClassTest&quot;, true, myLoader);// clazz0与clazz3并不相同System.out.println(&quot;Class对象是否相同:&quot; + clazz0.equals(clazz3));</code></pre><ul><li>通过 Class 的 getDeclaredXxxx 和 getXxx 方法获取构造器、方法和域对象，两者的区别在于前者返回的是当前 Class 对象申明的构造器、方法和域，包含修饰符为 private 的；后者只返回修饰符为 public 的构造器、方法和域，但包含从基类中继承的。</li></ul><pre><code>// 返回申明为public的方法，包含从基类中继承的for (Method method: String.class.getMethods()) {    System.out.println(method.getName());}// 返回当前类申明的所有方法，包含private的for (Method method: String.class.getDeclaredMethods()) {    System.out.println(method.getName());}</code></pre><ul><li>通过 Class 的 newInstance 方法和 Constructor 的 newInstance 方法方法均可新建类型为 Class 的对象，通过 Method 的 invoke 方法可以在运行时动态调用该方法，通过 Field 的 set 方法可以在运行时动态改变域的值，但需要首先设置其为可访问（setAccessible）。</li></ul><h3 id="二、注解"><a href="#二、注解" class="headerlink" title="二、注解"></a>二、注解</h3><p>注解（Annotation）是 Java5 引入的一种代码辅助工具，它的核心作用是对类、方法、变量、参数和包进行标注，通过反射来访问这些标注信息，以此在运行时改变所注解对象的行为。Java 中的注解由内置注解和元注解组成。内置注解主要包括：</p><ul><li>@Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li></ul><p>这里，我们重点关注元注解，元注解位于 java.lang.annotation 包中，主要用于自定义注解。元注解包括：</p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入 class 文件中，或者是在运行时可以通过反射访问，枚举类型分为别 SOURCE、CLASS 和 RUNTIME；</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员，枚举类型包括 TYPE、FIELD、METHOD、CONSTRUCTOR 等；</li><li>@Inherited - 标记这个注解可以继承超类注解，即子类 Class 对象可使用 getAnnotations() 方法获取父类被 @Inherited 修饰的注解，这个注解只能用来申明类。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><p>自定义元注解需重点关注两点：1）注解的数据类型；2）反射获取注解的方法。首先，注解中的方法并不支持所有的数据类型，仅支持<strong>八种基本数据类型、String、Class、enum、Annotation 和它们的数组</strong>。比如以下代码会产生编译时错误：</p><pre><code>@Documented@Inherited@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface AnnotationTest {    // 1. 注解数据类型不能是Object；2. 默认值不能为null    Object value() default null;    // 支持的定义方式    String value() default &quot;&quot;;}</code></pre><p>其次，上节中提到的反射相关类（Class、Constructor、Method 和 Field）和 Package 均实现了 AnnotatedElement 接口，该接口定义了访问反射信息的方法，主要如下：</p><pre><code>// 获取指定注解类型getAnnotation(Class&lt;T&gt;):T;// 获取所有注解，包括从父类继承的getAnnotations():Annotation[];// 获取指定注解类型，不包括从父类继承的getDeclaredAnnotation(Class&lt;T&gt;):T// 获取所有注解，不包括从父类继承的getDeclaredAnnotations():Annotation[];// 判断是否存在指定注解isAnnotationPresent(Class&lt;? extends Annotation&gt;:boolean</code></pre><p>当使用上例中的 AnnotationTest 标注某个类后，便可在运行时通过该类的反射方法访问注解信息了。</p><pre><code>@AnnotationTest(&quot;yhthu&quot;)public class AnnotationReflection {    public static void main(String[] args) {        AnnotationReflection ar = new AnnotationReflection();        Class clazz = ar.getClass();        // 判断是否存在指定注解        if (clazz.isAnnotationPresent(AnnotationTest.class)) {            // 获取指定注解类型            Annotation annotation = clazz.getAnnotation(AnnotationTest.class);            // 获取该注解的值            System.out.println(((AnnotationTest) annotation).value());        }    }}</code></pre><blockquote><p>当自定义注解只有一个方法 value() 时，使用注解可只写值，例如：@AnnotationTest(“yhthu”)</p></blockquote><h3 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a>三、动态代理</h3><p>参考上一篇：<a href="https://topone233.github.io/2020/07/20/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%9C%E7%94%A8/">动态代理</a></p><p>代理是一种结构型设计模式，当无法或不想直接访问某个对象，或者访问某个对象比较复杂的时候，可以通过一个代理对象来间接访问，代理对象向客户端提供和真实对象同样的接口功能。经典设计模式中，代理模式有四种角色：</p><ul><li>Subject 抽象主题类——申明代理对象和真实对象共同的接口方法；</li><li>RealSubject 真实主题类——实现了 Subject 接口，真实执行业务逻辑的地方；</li><li>ProxySubject 代理类——实现了 Subject 接口，持有对 RealSubject 的引用，在实现的接口方法中调用 RealSubject 中相应的方法执行；</li><li>Cliect 客户端类——使用代理对象的类。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3923557-d5887810ae72a4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在实现上，代理模式分为静态代理和动态代理，静态代理的代理类二进制文件是在编译时生成的，而动态代理的代理类二进制文件是在运行时生成并加载到虚拟机环境的。JDK 提供了对动态代理接口的支持，开源的动态代理库（Cglib、Javassist 和 Byte Buddy）提供了对接口和类的代理支持，本节将简单比较 JDK 和 Cglib 实现动态代理的异同，后续章节会对 Java 字节码编程做详细分析。</p><h4 id="3-1-JDK-动态代理接口"><a href="#3-1-JDK-动态代理接口" class="headerlink" title="3.1 JDK 动态代理接口"></a>3.1 JDK 动态代理接口</h4><p>JDK 实现动态代理是通过 Proxy 类的 newProxyInstance 方法实现的，该方法的三个入参分别表示：</p><pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code></pre><ul><li>ClassLoader loader，定义代理生成的类的加载器，可以自定义类加载器，也可以复用当前 Class 的类加载器；</li><li>Class&lt;?&gt;[] interfaces，定义代理对象需要实现的接口；</li><li>InvocationHandler h，定义代理对象调用方法的处理，其 invoke 方法中的 Object proxy 表示生成的代理对象，Method 表示代理方法， Object[] 表示方法的参数。</li></ul><p>通常的使用方法如下：</p><pre><code>private Object getProxy() {    return Proxy.newProxyInstance(JDKProxyTest.class.getClassLoader(), new Class&lt;?&gt;[]{Subject.class},            new MyInvocationHandler(new RealSubject()));}private static class MyInvocationHandler implements InvocationHandler {    private Object realSubject;    public MyInvocationHandler(Object realSubject) {        this.realSubject = realSubject;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;Some thing before method invoke&quot;);        Object result = method.invoke(realSubject, args);        System.out.println(&quot;Some thing after method invoke&quot;);        return result;    }}</code></pre><p>类加载器采用当前类的加载器，默认为应用程序类加载器（sun.misc.Launcher$AppClassLoader）；接口数组以 Subject.class 为例，调用方法处理类 MyInvocationHandler 实现 InvocationHandler 接口，并在构造器中传入 Subject 的真正的业务功能服务类 RealSubject，在执行 invoke 方法时，可以在实际方法调用前后织入自定义的处理逻辑，这也就是 AOP（面向切面编程）的原理。<br>关于 JDK 动态代理，有两个问题需要清楚：</p><ul><li>Proxy.newProxyInstance 的代理类是如何生成的？Proxy.newProxyInstance 生成代理类的核心分成两步：</li></ul><pre><code>// 1. 获取代理类的Class对象Class&lt;?&gt; cl = getProxyClass0(loader, intfs);// 2. 利用Class获取Constructor，通过反射生成对象cons.newInstance(new Object[]{h});</code></pre><p>与反射获取 Class 对象时搜索 classpath 路径的. class 文件不同的是，这里的 Class 对象完全是 “无中生有” 的。getProxyClass0 根据类加载器和接口集合返回了 Class 对象，这里采用了缓存的处理。</p><pre><code>// 缓存(key, sub-key) -&gt; value，其中key为类加载器，sub-key为代理的接口，value为Class对象private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;    proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());// 如果实现了代理接口的类已存在就返回缓存对象，否则就通过ProxyClassFactory生成private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) {    if (interfaces.length &gt; 65535) {        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);    }    return proxyClassCache.get(loader, interfaces);}</code></pre><p>如果实现了代理接口的类已存在就返回缓存对象，否则就通过 ProxyClassFactory 生成。ProxyClassFactory 又是通过下面的代码生成 Class 对象的。</p><pre><code>// 生成代理类字节码文件byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);try {    // defineClass0为native方法，生成Class对象    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);} catch (ClassFormatError e) {    throw new IllegalArgumentException(e.toString());}</code></pre><p>generateProxyClass 方法是用来生成字节码文件的，根据生成的字节码文件，再在 native 层生成 Class 对象。</p><ul><li>InvocationHandler 的 invoke 方法是怎样调用的？<br>回答这个问题得先看下上面生成的 Class 对象究竟是什么样的，将 ProxyGenerator 生成的字节码保存成文件，然后反编译打开（IDEA 直接打开），可见生成的 Proxy.class 主要包含 equals、toString、hashCode 和代理接口的 request 方法实现。</li></ul><pre><code>public final class $Proxy extends Proxy implements Subject {    // m1 = Object的equals方法    private static Method m1;    // m2 = Object的toString方法    private static Method m2;    // Subject的request方法    private static Method m3;    // Object的hashCode方法    private static Method m0;    // 省略m1/m2/m0，此处只列出request方法实现    public final void request() throws  {        try {            super.h.invoke(this, m3, (Object[])null);        } catch (RuntimeException | Error var2) {            throw var2;        } catch (Throwable var3) {            throw new UndeclaredThrowableException(var3);        }    }   }</code></pre><p>由于生成的代理类继承自 Proxy，super.h 即是 Prxoy 的 InvocationHandler，即代理类的 request 方法直接调用了 InvocationHandler 的实现，这就回答了 InvocationHandler 的 invoke 方法是如何被调用的了。</p><h4 id="3-2-Cglib-动态代理接口和类"><a href="#3-2-Cglib-动态代理接口和类" class="headerlink" title="3.2 Cglib 动态代理接口和类"></a>3.2 Cglib 动态代理接口和类</h4><p>Cglib 的动态代理是通过 Enhancer 类实现的，其 create 方法生成动态代理的对象，有五个重载方法：</p><pre><code>create():Objectcreate(Class, Callback):Objectcreate(Class, Class[], Callback):Objectcreate(Class, Class[], CallbackFilter, Callback):Objectcreate(Class[], Object):Object</code></pre><p>常用的是第二个和第三个方法，分别用于动态代理类和动态代理接口，其使用方法如下：</p><pre><code>private Object getProxy() {    // 1. 动态代理类    return Enhancer.create(RealSubject.class, new MyMethodInterceptor());    // 2. 动态代理接口    return Enhancer.create(Object.class, new Class&lt;?&gt;[]{Subject.class}, new MyMethodInterceptor());}private static class MyMethodInterceptor implements MethodInterceptor {    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {        System.out.println(&quot;Some thing before method invoke&quot;);        Object result = proxy.invokeSuper(obj, args);        System.out.println(&quot;Some thing after method invoke&quot;);        return result;    }}</code></pre><p>从上小节可知，JDK 只能代理接口，代理生成的类实现了接口的方法；而 Cglib 是通过继承被代理的类、重写其方法来实现的，如：create 方法入参的第一个参数就是被代理类的类型。当然，Cglib 也能代理接口，比如 getProxy() 方法中的第二种方式。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="/2020/07/20/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2020/07/20/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.zhihu.com/question/20794107/answer/811250346" target="_blank" rel="noopener">原文地址</a> </p></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理：消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。类似于生活中的中介。</p><p>有一个打印机的类</p><pre><code>public class Printer {    public void print(){        System.out.println(&quot;打印！&quot;);    }}</code></pre><p>我想在打印之前先记录一下日志怎么做？</p><p>最简单的方法：在打印的功能前面直接加上记录日志的功能。</p><pre><code>public class Printer {    public void print(){        System.out.println(&quot;记录日志！&quot;);        System.out.println(&quot;打印！&quot;);    }  }</code></pre><p>看上去好像没有问题，但是我们修改了打印机的源代码，<strong>破坏了面向对象的开闭原则</strong>，有可能影响到其它功能。怎么解决呢？很容易可以想到，既然不能修改原来的代码，那我新建一个类吧。</p><pre><code>public class LogPrinter extends Printer {    public void print(){        System.out.println(&quot;记录日志！&quot;);        System.out.println(&quot;打印！&quot;);    }}</code></pre><p>这个类继承了打印机的类，<strong>重写了打印机的 print 方法，提供了记录日志的功能</strong>，以后需要打印机的时候使用这个类就好。问题似乎得到了解决，我们可以在这个解决方案的基础上进一步的优化：</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>先抽象出一个接口:</p><pre><code>public interface IPrinter {    void print();}</code></pre><p>打印机类（被代理类）实现这个接口:</p><pre><code>public class Printer implements IPrinter {       @Override       public void print(){               System.out.println(&quot;打印！&quot;);    }}</code></pre><p><strong>创建打印机代理类</strong>也实现该接口</p><p>被代理类被传递给了代理类PrinterProxy，代理类在执行具体方法时通过所持用的被代理类完成调用。</p><p>在构造函数中将打印机对象传进去，实现接口的打印方法时调用打印机对象的打印方法并在前面加上记录日志的功能:</p><pre><code>public class PrinterProxy implements IPrinter {    private IPrinter printer;    public PrinterProxy(){        this.printer = new printer();    }    @Override    public void print() {        System.out.println(&quot;记录日志&quot;);        printer.print();    }}</code></pre><p>试一把：</p><pre><code>public class Test {    public static void main(String[] args) {        PrinterProxy proxy = new PrinterProxy();        proxy.print();    }}</code></pre><p>结果出来了：</p><pre><code>记录日志打印</code></pre><p><strong>以后我们就可以直接实例化 PrinterProxy 对象调用它的打印方法了，这就是静态代理模式，通过抽象出接口让程序的扩展性和灵活性更高了。</strong></p><h4 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h4><p>静态代理是完美无缺的吗？</p><p>考虑一下，如果我的打印机类中还有别的方法，也需要加上记录日志的功能，但是静态代理只能为一个类服务，就不得不将记录日志的功能写 n 遍。进一步如果我还有电视机，电冰箱的类里面的所有方法也需要加上记录日志的功能，那要重复的地方就更多了。</p><p>怎么办？</p><p>动态代理闪亮登场：</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>要想不重复写记录日志的功能，<strong>针对每一个接口实现一个代理类的做法肯定不可行了</strong>，可不可以让这些代理类的对象<strong>自动生成</strong>呢？</p><p>利用反射机制在运行时创建代理类。</p><p>Jdk 提供了 <strong>invocationHandler</strong> 接口和 <strong>Proxy</strong> 类，借助这两个工具可以达到我们想要的效果。</p><p>invocationHandler 接口上场：</p><pre><code>//Object proxy:被代理的对象 //Method method:要调用的方法 //Object[] args:方法调用时所需要参数 public interface InvocationHandler {     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;}</code></pre><p>接口里只有一个方法 invoke，这个方法非常重要，先混个脸熟，稍后解释。</p><p>Proxy 类上场，它里面有一个很重要的方法 newProxyInstance：</p><pre><code>//CLassLoader loader:被代理对象的类加载器 //Class&lt;?&gt; interfaces:被代理类全部的接口 //InvocationHandler h:实现InvocationHandler接口的对象  public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException </code></pre><p><strong>调用 Proxy 的 newProxyInstance 方法可以生成代理对象</strong></p><p>一切准备就绪动态代理模式千呼万唤始出来：</p><p>接口 IPrinter 和 该接口的实现类 Printer 的代码同前。</p><p><em>实现一个类，该类用来创建代理对象，</em><strong>_它实现了_InvocationHandler 接口</strong>：</p><pre><code>public class ProxyHandler implements InvocationHandler {    private Object targetObject;//被代理的对象    //将被代理的对象传入获得它的类加载器和实现接口作为Proxy.newProxyInstance方法的参数。    public Object newProxyInstance(Object targetObject){        this.targetObject = targetObject;        //targetObject.getClass().getClassLoader()：被代理对象的类加载器        //targetObject.getClass().getInterfaces()：被代理对象的实现接口        //this 当前对象，该对象实现了InvocationHandler接口所以有invoke方法，通过invoke方法可以调用被代理对象的方法        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),targetObject.getClass().getInterfaces(),this);    }    //该方法在代理对象调用方法时调用    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;记录日志&quot;);        return method.invoke(targetObject,args);    }}</code></pre><p>被代理的对象 targetObject 可以通过方法参数传进来：</p><pre><code>public Object newProxyInstance(Object targetObject){       this.targetObject=targetObject;</code></pre><p>我们重点来分析一下这段代码：</p><pre><code>return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),targetObject.getClass().getInterfaces(),this);</code></pre><p><strong>动态代理对象就是通过调用这段代码被创建并返回的</strong>。</p><p>方法有三个参数：</p><p>第一个参数：</p><p>targetObject.getClass().getClassLoader()：targetObject 对象的类加载器。</p><p>第二个参数:</p><p>targetObject.getClass().getInterfaces()：targetObject 对象的所有接口</p><p>第三个参数:</p><p>this：也就是当前对象即实现了 InvocationHandler 接口的类的对象，<strong>在调用方法时会调用它的 invoke 方法。</strong></p><p>再来看一下这段代码：</p><pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {      //在这里可以通过判断方法名来决定执行什么功能      System.out.println(&quot;记录日志&quot;);      //调用被代理对象的方法      return method.invoke(targetObject, args);}</code></pre><p>这个方法就是生成的代理类中的方法被调用时会去自动调用的方法，可以看到在这个方法中调用了被代理对象的方法: method.invoke(targetObject, args);</p><p><strong>我们可以在这里加上需要的业务逻辑，比如调用方法前记录日志功能.</strong></p><p>见证奇迹的时刻到了：</p><pre><code>public class Test {   public static void main(String[] args){   ProxyHandler proxyHandler=new ProxyHandler();   IPrinter printer = (IPrinter) proxyHandler.newProxyInstance(new Printer());   printer.print();   }}</code></pre><p>打印结果：</p><pre><code>记录日志打印</code></pre><p>当执行 printer.print(); 时会自动调用 invoke 方法，很多初学者不理解为什么能调用这个方法，回忆一下创建代理对象的时候是通过</p><pre><code>return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),targetObject.getClass().getInterfaces(),this);</code></pre><p>来创建的，方法的第三个参数 this 是实现了 InvocationHandler 接口的对象， InvocationHandler 接口有 invoke 方法。现在有点思路了吧~</p><p>将被代理的对象作为参数传入就可以执行里面的任意方法，所有的方法调用都通过 invoke 来完成。不用对每个方法进行处理，动态代理是不是很简洁。</p><h4 id="动态代理的优势"><a href="#动态代理的优势" class="headerlink" title="动态代理的优势"></a>动态代理的优势</h4><ol><li>Proxy 类的代码量被固定下来，不会因为业务的逐渐庞大而庞大；</li><li>可以实现 AOP 编程，实际上静态代理也可以实现，总的来说，AOP 可以算作是代理模式的一个典型应用；</li><li>解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。</li></ol><h4 id="复习对象的创建"><a href="#复习对象的创建" class="headerlink" title="复习对象的创建"></a>复习对象的创建</h4><p>很多初学 Java 的朋友眼中创建对象的过程</p><p><img src="https://pic4.zhimg.com/v2-9cd31ab516bd967e1b8e68736931f8ba_r.jpg?source=1940ef5c" alt=""></p><p>实际上可以换个角度，也说得通</p><p><img src="https://pic1.zhimg.com/v2-eddc430b991c58039dfc79dd6f3139cc_r.jpg?source=1940ef5c" alt=""></p><p>所谓的 Class 对象，是 Class 类的实例，而 Class 类是描述所有类的，比如 Person 类，Student 类</p><p><img src="https://pic2.zhimg.com/v2-c9bf695b1b9d2a0ae01cf92501492159_r.jpg?source=1940ef5c" alt=""></p><p>可以看出，要创建一个实例，最关键的就是<strong>得到对应的 Class 对象。</strong>只不过对于初学者来说，new 这个关键字配合构造方法，实在太好用了，底层隐藏了太多细节，一句 Person p = new Person(); 直接把对象返回给你了。我自己刚开始学 Java 时，也没意识到 Class 对象的存在。</p><p>分析到这里，貌似有了思路：</p><blockquote><p>能否不写代理类，而直接得到代理 Class 对象，然后根据它创建代理实例（反射) ?</p></blockquote><p>Class 对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。<strong>之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。</strong>还是上面这幅图：</p><p><img src="https://pic3.zhimg.com/v2-e302487f952bdf8e284afc0d8d6a770b_r.jpg?source=1940ef5c" alt=""></p><p>所以，可以这样说：接口拥有代理对象和目标对象共同的类信息。所以，我们可以从接口那得到理应由代理类提供的信息。但是别忘了，接口是无法创建对象的，怎么办？</p><p>JDK 提供了 java.lang.reflect.InvocationHandler 接口和 java.lang.reflect.Proxy 类，这两个类相互配合，入口是 Proxy，所以我们先聊它。</p><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>Proxy 有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理 Class 对象。</p><p>用通俗的话说，getProxyClass() 这个方法，会从你传入的接口 Class 中，“拷贝” 类结构信息到一个新的 Class 对象中，但新的 Class 对象带有构造器，是可以创建对象的。打个比方，一个大内太监（接口 Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy 类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小 DD（构造器）…（这到底是道德の沦丧，还是人性的扭曲，欢迎走进动态代理）</p><p>所以，一旦我们明确接口，完全可以通过接口的 Class 对象，创建一个代理 Class，通过代理 Class 即可创建代理对象。</p><img src="https://pic3.zhimg.com/v2-d187a82b1eb9c088fe60327828ee63aa_r.jpg?source=1940ef5c"  /><p><img src="https://pic3.zhimg.com/v2-28223a1c03c1800052a5dfe4e6cb8c53_r.jpg?source=1940ef5c" alt=""></p><p><img src="https://pic1.zhimg.com/v2-ba3d9206f341be466f18afbdd938a3b3_r.jpg?source=1940ef5c" alt=""></p><p>所以，按我理解，Proxy.getProxyClass() 这个方法的本质就是：<strong>以 Class 造 Class。</strong></p><p>有了 Class 对象，就很好办了，具体看代码：</p><p><img src="https://pic4.zhimg.com/v2-6b091b6d41bae1f88ba74a510acb24b1_r.jpg?source=1940ef5c" alt=""></p><p>完美。</p><p>根据代理 Class 的构造器创建对象时，需要传入 InvocationHandler。每次调用代理对象的方法，最终都会调用 InvocationHandler 的 invoke() 方法：</p><p><img src="https://pic1.zhimg.com/v2-92610586e77cf71ba5ce89087de52ff1_r.jpg?source=1940ef5c" alt=""></p><p>怎么做到的呢？</p><p>上面不是说了吗，根据代理 Class 的构造器创建对象时，需要传入 InvocationHandler。<strong>通过构造器传入一个引用，那么必然有个成员变量去接收。</strong>没错，代理对象的内部确实有个成员变量 invocationHandler，而且代理对象的每个方法内部都会调用 handler.invoke()！InvocationHandler 对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。</p><p><img src="https://pic4.zhimg.com/v2-b5fc8b279a6152889afdfedbb0f611cc_r.jpg?source=1940ef5c" alt=""></p><p>大家仔细看上图右侧的动态代理，我在 invocationHandler 的 invoke() 方法中并没有写目标对象。因为一开始 invocationHandler 的 invoke() 里确实没有目标对象，需要我们手动 new。</p><p><img src="https://pic3.zhimg.com/v2-88147b81ee9342015374159b2671320b_r.jpg?source=1940ef5c" alt=""></p><p>但这种写法不够优雅，属于硬编码。我这次代理 A 对象，下次想代理 B 对象还要进来改 invoke() 方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来：</p><pre><code>public class ProxyTest {    public static void main(String[] args) throws Throwable {        CalculatorImpl target = new CalculatorImpl();                //传入目标对象                //目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法        Calculator calculatorProxy = (Calculator) getProxy(target);        calculatorProxy.add(1, 2);        calculatorProxy.subtract(2, 1);    }    private static Object getProxy(final Object target) throws Exception {        //参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口        Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());        Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);        Object proxy = constructor.newInstance(new InvocationHandler() {            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                System.out.println(method.getName() + &quot;方法开始执行...&quot;);                Object result = method.invoke(target, args);                System.out.println(result);                System.out.println(method.getName() + &quot;方法执行结束...&quot;);                return result;            }        });        return proxy;    }}</code></pre><p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你把实例传进来，getProxy() 都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p><p>不过实际编程中，一般不用 getProxyClass()，而是使用 Proxy 类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理 Class 对象的过程都帮你隐藏：</p><pre><code>public class ProxyTest {    public static void main(String[] args) throws Throwable {        CalculatorImpl target = new CalculatorImpl();        Calculator calculatorProxy = (Calculator) getProxy(target);        calculatorProxy.add(1, 2);        calculatorProxy.subtract(2, 1);    }    private static Object getProxy(final Object target) throws Exception {        Object proxy = Proxy.newProxyInstance(                target.getClass().getClassLoader(),/*类加载器*/                target.getClass().getInterfaces(),/*让代理对象和目标对象实现相同接口*/                new InvocationHandler(){/*代理对象的方法最终都会被JVM导向它的invoke方法*/                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                        System.out.println(method.getName() + &quot;方法开始执行...&quot;);                        Object result = method.invoke(target, args);                        System.out.println(result);                        System.out.println(method.getName() + &quot;方法执行结束...&quot;);                        return result;                    }                }        );        return proxy;    }}</code></pre><p>现在，我想应该能看懂动态代理了。</p><p><img src="https://pic2.zhimg.com/v2-6aacbe1e9df4fe982a68fe142401952e_r.jpg?source=1940ef5c" alt=""></p><p>最后讨论一下代理对象是什么类型。</p><p>首先，请区分两个概念：代理 Class 对象和代理对象。</p><p><img src="https://pic4.zhimg.com/v2-bb82bd129d63f77265f51b2209159269_r.jpg?source=1940ef5c" alt=""></p><p>单从名字看，代理 Class 和 Calculator 的接口确实相去甚远，但是我们却能将代理对象赋值给接口类型：</p><p><img src="https://pic1.zhimg.com/v2-e869e67fc4fbc708b793ff6ea6e2c012_r.jpg?source=1940ef5c" alt=""></p><p>千万别觉得名字奇怪，就怀疑它不能用接口接收，只要实现该接口就是该类型。</p><p>代理对象的本质就是：和目标对象实现相同接口的实例。代理 Class 可以叫任何名字，whatever，只要它实现某个接口，就能成为该接口类型。</p><p><img src="https://pic4.zhimg.com/v2-91d716b1a95099ad364233de91fca7a3_r.jpg?source=1940ef5c" alt=""></p><p>我写了一个 MyProxy 类，那么它的 Class 名字必然叫 MyProxy。<strong>但这和能否赋值给接口没有任何关系。</strong>由于它实现了 Serializable 和 Collection，所以 myProxy（代理实例）<strong>同时</strong>是这两个接口的类型。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我想了个很骚的比喻，希望能解释清楚：</p><p>接口 Class 对象是大内太监，里面的方法和字段比做他的一身武艺，但是他没有小 DD（构造器），所以不能 new 实例。一身武艺后继无人。</p><p>那怎么办呢？</p><p>正常途径（implements）：</p><p>写一个类，实现该接口。这个就相当于大街上拉了一个人，认他做干爹。一身武艺传给他，只是比他干爹多了小 DD，可以 new 实例。</p><p>非正常途径（动态代理）：</p><p>通过妙手圣医 Proxy 的克隆大法（Proxy.getProxyClass()），克隆一个 Class，但是有小 DD。所以这个克隆人 Class 可以创建实例，也就是代理对象。</p><p>代理 Class 其实就是附有构造器的接口 Class，一样的类结构信息，却能创建实例。</p><p><img src="https://pic2.zhimg.com/v2-33094b28321ab388bb0db46608eae74a_r.jpg?source=1940ef5c" alt="">JDK 动态代理生成的实例</p><p><img src="https://pic3.zhimg.com/v2-b99009ee292273a56ab483170b2e20aa_r.jpg?source=1940ef5c" alt=""> </p><p>CGLib 动态代理生成的实例</p><p>如果说继承的父类是亲爹（只有一个），那么实现的接口是干爹（可以有多个）。</p><p>实现接口是一个类认干爹的过程。接口无法创建对象，但实现该接口的类可以。</p><p>比如</p><pre><code>class Student extends Person implements A, B</code></pre><p>这个类 new 一个实例出来，你问它：你爸爸是谁啊？它会告诉你：我只有一个爸爸 Person。</p><p>但是 student instanceof A interface，或者 student instanceof B interface，它会告诉你两个都是它干爹（true），都可以用来接收它。</p><p><img src="https://pic2.zhimg.com/v2-1c36d27a6a2a49a266a7fc2ed457e532_r.jpg?source=1940ef5c" alt=""></p><p>然而，凡是有利必有弊。</p><p><img src="https://pic1.zhimg.com/v2-991ea99b9038d52875ff6ba57e9032de_r.jpg?source=1940ef5c" alt=""></p><p>也就是说，动态代理生成的代理对象，最终都可以用接口接收，和目标对象一起形成了多态，可以随意切换展示不同的功能。但是切换的同时，只能使用该接口定义的方法。</p><hr><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>初学者可能对诸如 “字节码文件”、Class 对象比较陌生。所以这里花一点点篇幅介绍一下类加载器的部分原理。如果我们要定义类加载器，需要继承 ClassLoader 类，并覆盖 findClass() 方法：</p><pre><code>@Overridepublic Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {    try {        /*自己另外写一个getClassData()                  通过IO流从指定位置读取xxx.class文件得到字节数组*/        byte[] datas = getClassData(name);        if(datas == null) {            throw new ClassNotFoundException(&quot;类没有找到：&quot; + name);        }        //调用类加载器本身的defineClass()方法，由字节码得到Class对象        return this.defineClass(name, datas, 0, datas.length);    } catch (IOException e) {        e.printStackTrace();        throw new ClassNotFoundException(&quot;类找不到：&quot; + name);    }}</code></pre><p>所以，这就是类加载之所以能把 xxx.class 文件加载进内存，并创建对应 Class 对象的深层原因。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World！（hexo配置记录）</title>
      <link href="/2020/07/10/Hello%20World%EF%BC%81%EF%BC%88hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%EF%BC%89/"/>
      <url>/2020/07/10/Hello%20World%EF%BC%81%EF%BC%88hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World！（hexo配置记录）"><a href="#Hello-World！（hexo配置记录）" class="headerlink" title="Hello World！（hexo配置记录）"></a>Hello World！（hexo配置记录）</h1><p>以前在网上冲浪的时候只是不经意间发现许多让人眼前一亮的blog，由此萌生了create my blog的想法。</p><p>目前的blog搭建：</p><ul><li><p>CSDN/博客园平台  </p><p> 但我个人不是很喜欢这种，首先是太丑了（没错，就是你，CSDN）。  </p><p> 其次依托于平台，虽然只需要创作就行，但是感觉不是属于自己的，没有归属感</p></li><li><p>独立blog  </p><p> 租云服务器、买域名，还要管理维护，个人感觉略微有些费事，精力有限，还是简单点好</p></li><li><p>hexo  </p><p> 依托于Github，也是我目前选择的，配置相对简单快捷，主题丰富</p></li></ul><hr><h3 id="hexo配置步骤："><a href="#hexo配置步骤：" class="headerlink" title="hexo配置步骤："></a>hexo配置步骤：</h3><ul><li>安装Git</li><li>安装Node.js</li><li>安装hexo</li><li>生成ssh并添加到GitHub</li><li>部署项目</li><li>上传到GitHub</li><li>修改主题</li></ul><h4 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h4><p><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">下载地址</a>  </p><p>安装步骤：双击下载的exe文件，一路next就行</p><h4 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h4><p>Hexo是基于nodeJS环境的静态博客，npm是必备的  </p><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>  </p><p>安装步骤：下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了</p><h4 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h4><ol><li>创建一个源文件夹，然后cd到该文件夹下</li><li>安装hexo： npm i -g hexo </li><li>hexo -v 查看版本，检查是否安装成功</li><li>hexo init 初始化，初始化完成后可在文件夹下看到文件</li></ol><p>这里要说下，npm install出现一直停留在”fetchMetadata: sill resolveWithNewModule find-cache-dir@”解决方法，更换成淘宝的源（反正我是解决了）</p><pre><code>//修改为淘宝源npm config set registry https://registry.npm.taobao.org //配置后可通过下面方式来验证是否成功 npm config get registry //或npm info express</code></pre><h4 id="4-生成ssh并添加到GitHub"><a href="#4-生成ssh并添加到GitHub" class="headerlink" title="4.生成ssh并添加到GitHub"></a>4.生成ssh并添加到GitHub</h4><p>SSH密钥可以防止其他人恶意部署文件到你的仓库  </p><p>首先要有GitHub账号，没有的自行注册  </p><p>创建一个仓库repository，名称为youname.github.io  </p><p>在gitbash中，配置GitHub账号信息</p><pre><code>//配置你的GitHub账号信息git config --global user.name &quot;YourName&quot;git config --global user.email &quot;YourEmail&quot;</code></pre><p>创建ssh</p><pre><code>//创建sshssh-keygen -t rsa -C &quot;youremail@xx.com&quot;</code></pre><p>生成ssh，在gitbash中切换到文件目录cat读取</p><pre><code>//读取ssh文件内容cat id_rsa.pub </code></pre><p>全部复制（包括开头的ssh-rsa，和尾部的email）<br>到GitHub 配置ssh，title随便起</p><h4 id="5-部署项目"><a href="#5-部署项目" class="headerlink" title="5.部署项目"></a>5.部署项目</h4><p>修改hexo的_config.yml文件配置信息（直接复制，只需要修改url即可）</p><pre><code>deploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master</code></pre><p>回到gitbash，进入hexo目录</p><pre><code>hexo cleanhexo generatehexo server</code></pre><p>这时，在<a href="http://localhost:4000就可以看到默认页面">http://localhost:4000就可以看到默认页面</a></p><h4 id="6-上传到GitHub"><a href="#6-上传到GitHub" class="headerlink" title="6.上传到GitHub"></a>6.上传到GitHub</h4><pre><code>npm install hexo-deployer-git --save</code></pre><p>将写好的文章部署到GitHub服务器，<br>执行命令</p><pre><code>hexo cleanhexo generatehexo deploy </code></pre><p>第一次deploy要输入GitHubusername和password<br>完成后<a href="https://yourgithubname.github.io，查看即可" target="_blank" rel="noopener">https://yourgithubname.github.io，查看即可</a></p><h4 id="7-修改主题"><a href="#7-修改主题" class="headerlink" title="7.修改主题"></a>7.修改主题</h4><p>hexo官网有推荐很多很多主题，自行选择</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 剖析 (基于 jdk1.8)</title>
      <link href="/2020/07/10/HashMap%20%E5%89%96%E6%9E%90%20(%E5%9F%BA%E4%BA%8E%20jdk1.8)/"/>
      <url>/2020/07/10/HashMap%20%E5%89%96%E6%9E%90%20(%E5%9F%BA%E4%BA%8E%20jdk1.8)/</url>
      
        <content type="html"><![CDATA[<p>原文地址 <a href="https://www.cnblogs.com/Young111/p/11471049.html" target="_blank" rel="noopener">www.cnblogs.com</a></p><p>本文的源码是基于 JDK1.8 版本，在学习 HashMap 之前，先了解数组和链表的知识。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组具有遍历快，增删慢的特点。数组在堆中是一块连续的存储空间，遍历时数组的首地址是知道的（首地址 = 首地址 + 元素字节数 * 下标），所以遍历快（数组遍历的时间复杂度为 O(1) ）；增删慢是因为，当在中间插入或删除元素时，会造成该元素后面所有元素地址的改变，所以增删慢（增删的时间复杂度为 O(n) ）。</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表具有增删快，遍历慢的特点。链表中各元素的内存空间是不连续的，一个节点至少包含节点数据与后继节点的引用，所以在插入删除时，只需修改该位置的前驱节点与后继节点即可，链表在插入删除时的时间复杂度为 O(1)。但是在遍历时，get(n) 元素时，需要从第一个开始，依次拿到后面元素的地址，进行遍历，直到遍历到第 n 个元素（时间复杂度为 O(n) ），所以效率极低。</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>Hash 表是一个数组 + 链表的结构，这种结构能够保证在遍历与增删的过程中，如果不产生 hash 碰撞，仅需一次定位就可完成，时间复杂度能保证在 O(1)。  在 jdk1.7 中，只是单纯的数组 + 链表的结构，但是如果散列表中的 hash 碰撞过多时，会造成效率的降低，所以在 JKD1.8 中对这种情况进行了控制，当一个 hash 值上的链表长度大于 8 时，该节点上的数据就不再以链表进行存储，而是转成了一个红黑树。</p><p>红黑树:</p><pre><code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {    TreeNode&lt;K,V&gt; parent;  // red-black tree links    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion    boolean red;}</code></pre><h4 id="hash-碰撞"><a href="#hash-碰撞" class="headerlink" title="hash 碰撞"></a>hash 碰撞</h4><p>hash 是指，两个元素通过 hash 函数计算出的值是一样的，是同一个存储地址。当后面的元素要插入到这个地址时，发现已经被占用了，这时候就产生了 hash 冲突</p><h4 id="hash-冲突的解决方法"><a href="#hash-冲突的解决方法" class="headerlink" title="hash 冲突的解决方法"></a>hash 冲突的解决方法</h4><p>开放定址法 (查询产生冲突的地址的下一个地址是否被占用，直到寻找到空的地址)，再散列法，链地址法等。hashmap 采用的就是链地址法，jdk1.7 中，当冲突时，在冲突的地址上生成一个链表，将冲突的元素的 key，通过 equals 进行比较，相同即覆盖，不同则添加到链表上，此时如果链表过长，效率就会大大降低，查找和添加操作的时间复杂度都为 O(n)；但是在 jdk1.8 中如果链表长度大于 8，链表就会转化为红黑树，下图就是 1.8 版本的（图片来源 <a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722</a>），时间复杂度也降为了 O(logn)，性能得到了很大的优化。</p><p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906090342350-1437652164.png" alt=""></p><h4 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h4><p>首先，hashMap 的主干是一个 Node 数组（jdk1.7 及之前为 Entry 数组）每一个 Node 包含一个 key 与 value 的键值对，与一个 next 指向下一个 node，hashMap 由多个 Node 对象组成。</p><p>Node 是 HhaspMap 中的一个静态内部类 ：</p><pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {         final int hash;         final K key;         V value;         Node&lt;K,V&gt; next;         Node(int hash, K key, V value, Node&lt;K,V&gt; next) {            this.hash = hash;             this.key = key;             this.value = value;             this.next = next;         }         public final K getKey()        { return key; }         public final V getValue()      { return value; }         public final String toString() { return key + &quot;=&quot; + value; }        //hashCode等其他代码     }</code></pre><p>再看下 hashMap 中几个重要的字段：</p><pre><code>//默认初始容量为16，0000 0001 左移4位 0001 0000为16，主干数组的初始容量为16，而且这个数组//必须是2的倍数(后面说为什么是2的倍数)static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//最大容量为int的最大值除2static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认加载因子为0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;//阈值，如果主干数组上的链表的长度大于8，链表转化为红黑树 static final int TREEIFY_THRESHOLD = 8;//hash表扩容后，如果发现某一个红黑树的长度小于6，则会重新退化为链表 static final int UNTREEIFY_THRESHOLD = 6;//当hashmap容量大于64时，链表才能转成红黑树 static final int MIN_TREEIFY_CAPACITY = 64;//临界值=主干数组容量*负载因子int threshold；</code></pre><h4 id="HashMap-的构造方法"><a href="#HashMap-的构造方法" class="headerlink" title="HashMap 的构造方法"></a>HashMap 的构造方法</h4><pre><code>//initialCapacity为初始容量，loadFactor为负载因子public HashMap(int initialCapacity, float loadFactor) {        //初始容量小于0，抛出非法数据异常        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        //初始容量最大为MAXIMUM_CAPACITY        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        //负载因子必须大于0，并且是合法数字        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;        //将初始容量转成2次幂        this.threshold = tableSizeFor(initialCapacity);    }    //tableSizeFor的作用就是，如果传入A，当A大于0，小于定义的最大容量时，    //如果A是2次幂则返回A，否则将A转化为一个比A大且差距最小的2次幂。      //例如传入7返回8，传入8返回8，传入9返回16  static final int tableSizeFor(int cap) {        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    }    //调用上面的构造方法，自定义初始容量，负载因子为默认的0.75 public HashMap(int initialCapacity) {        this(initialCapacity, DEFAULT_LOAD_FACTOR);    }    //默认构造方法，负载因子为0.75，初始容量为DEFAULT_INITIAL_CAPACITY=16，初始容量在第一次put时才会初始化 public HashMap() {        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted    }    //传入一个MAP集合的构造方法 public HashMap(Map&lt;? extends K, ? extends V&gt; m) {        this.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, false);    }</code></pre><h4 id="HashMap-的-put-方法"><a href="#HashMap-的-put-方法" class="headerlink" title="HashMap 的 put() 方法"></a>HashMap 的 put() 方法</h4><p>put 方法的源码分析是本篇的一个重点，因为通过该方法我们可以窥探到 HashMap 在内部是如何进行数据存储的，所谓的数组 + 链表 + 红黑树的存储结构是如何形成的，又是在何种情况下将链表转换成红黑树来优化性能的。带着一系列的疑问，我们看这个 put 方法：</p><pre><code>public V put(K key, V value) {       return putVal(hash(key), key, value, false, true);}</code></pre><p>也就是 put 方法调用了 putVal 方法，其中传入一个参数位 hash(key)，我们首先来看看 hash() 这个方法。</p><pre><code> static final int hash(Object key) {        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    }</code></pre><p>此处如果传入的 int 类型的值：①向一个 Object 类型赋值一个 int 的值时，会将 int 值自动封箱为 Integer。②integer 类型的 hashcode 都是他自身的值，即 h=key；h &gt;&gt;&gt; 16 为无符号右移 16 位，低位挤走，高位补 0；^ 为按位异或，即转成二进制后，相异为 1，相同为 0，由此可发现，当传入的值小于  2 的 16 次方 - 1 时，调用这个方法返回的值，都是自身的值。<br>然后再执行 putVal 方法：</p><pre><code>//onlyIfAbsent是true的话，不要改变现有的值//evict为true的话，表处于创建模式 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//如果主干上的table为空，长度为0，调用resize方法，调整table的长度（resize方法在下图中）        if ((tab = table) == null || (n = tab.length) == 0)            /* 这里调用resize，其实就是第一次put时，对数组进行初始化。               如果是默认构造方法会执行resize中的这几句话：               newCap = DEFAULT_INITIAL_CAPACITY;  新的容量等于默认值16               newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);                           threshold = newThr;   临界值等于16*0.75               Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];                table = newTab; 将新的node数组赋值给table，然后return newTab                如果是自定义的构造方法则会执行resize中的：                 int oldThr = threshold;                   newCap = oldThr;   新的容量等于threshold，这里的threshold都是2的倍数，原因在                    于传入的数都经过tableSizeFor方法，返回了一个新值，上面解释过                float ft = (float)newCap * loadFactor;                 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                (int)ft : Integer.MAX_VALUE);                  threshold = newThr; 新的临界值等于 (int)(新的容量*负载因子)                Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];                table = newTab; return newTab;            */            n = (tab = resize()).length;  //将调用resize后构造的数组的长度赋值给n        if ((p = tab[i = (n - 1) &amp; hash]) == null) //将数组长度与计算得到的hash值比较            tab[i] = newNode(hash, key, value, null);//位置为空，将i位置上赋值一个node对象        else {  //位置不为空            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;  // 如果这个位置的old节点与new节点的key完全相同                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                 e = p;             // 则e=p            else if (p instanceof TreeNode) // 如果p已经是树节点的一个实例，既这里已经是树了                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else {  //p与新节点既不完全相同，p也不是treenode的实例                for (int binCount = 0; ; ++binCount) {  //一个死循环                    if ((e = p.next) == null) {   //e=p.next,如果p的next指向为null                        p.next = newNode(hash, key, value, null);  //指向一个新的节点                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 如果链表长度大于等于8                            treeifyBin(tab, hash);  //将链表转为红黑树                        break;                    }       if (e.hash == hash &amp;&amp;  //如果遍历过程中链表中的元素与新添加的元素完全相同，则跳出循环                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e; //将p中的next赋值给p,即将链表中的下一个node赋值给p，                           //继续循环遍历链表中的元素                }            }            if (e != null) { //这个判断中代码作用为：如果添加的元素产生了hash冲突，那么调用                                             //put方法时，会将他在链表中他的上一个元素的值返回                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)  //判断条件成立的话，将oldvalue替换                        //为newvalue，返回oldvalue；不成立则不替换，然后返回oldvalue                    e.value = value;                afterNodeAccess(e);  //这个方法在后面说                return oldValue;            }        }        ++modCount;  //记录修改次数        if (++size &gt; threshold)   //如果元素数量大于临界值，则进行扩容            resize();   //下面说        afterNodeInsertion(evict);          return null;    }</code></pre><p>在 Java 8 中，如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8)，就使用红黑树来替换链表，从而提高速度。上诉代码这个替换的方法叫 treeifyBin() 即树形化。</p><p>看一下 treeifyBin() 的源码:</p><pre><code>//将桶内所有的 链表节点 替换成 红黑树节点 final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {   int n, index; Node&lt;K,V&gt; e;    //如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建/扩容   if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        //如果哈希表中的元素个数超过了 树形化阈值，进行树形化        // e 是哈希表中指定位置桶里的链表节点，从第一个开始        TreeNode&lt;K,V&gt; hd = null, tl = null; //红黑树的头、尾节点        do {            //新建一个树形节点，内容和当前链表节点 e 一致            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null) //确定树头节点                hd = p;           else {               p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);         //让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了        if ((tab[index] = hd) != null)            hd.treeify(tab);    } }    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {    return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); }</code></pre><p>注释已经很详细了，咱们说一下这个初始化的问题</p><pre><code>//如果 table 还未被初始化，那么初始化它if ((tab = table) == null || (n = tab.length) == 0)n = (tab = resize()).length;</code></pre><p>resize() 扩容机制，单元素如何散列到新的数组中，链表中的元素如何散列到新的数组中，红黑树中的元素如何散列到新的数组中？</p><pre><code> //上图中说了默认构造方法与自定义构造方法第一次执行resize的过程，这里再说一下扩容的过程    final Node&lt;K,V&gt;[] resize() {        Node&lt;K,V&gt;[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap &gt; 0) {  //扩容肯定执行这个分支            if (oldCap &gt;= MAXIMUM_CAPACITY) {   //当容量超过最大值时，临界值设置为int最大值                threshold = Integer.MAX_VALUE;                return oldTab;            }            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //扩容容量为2倍，临界值为2倍                newThr = oldThr &lt;&lt; 1;        }        else if (oldThr &gt; 0) // 不执行            newCap = oldThr;        else {                // 不执行            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        }        if (newThr == 0) {  // 不执行            float ft = (float)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        threshold = newThr;    //将新的临界值赋值赋值给threshold        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        table = newTab;   //新的数组赋值给table        //扩容后，重新计算元素新的位置        if (oldTab != null) {   //原数组            for (int j = 0; j &lt; oldCap; ++j) {   //通过原容量遍历原数组                Node&lt;K,V&gt; e;                if ((e = oldTab[j]) != null) {   //判断node是否为空，将j位置上的节点                //保存到e,然后将oldTab置为空，这里为什么要把他置为空呢，置为空有什么好处吗？？                //难道是吧oldTab变为一个空数组，便于垃圾回收？？ 这里不是很清楚                    oldTab[j] = null;                    if (e.next == null)          //判断node上是否有链表                        newTab[e.hash &amp; (newCap - 1)] = e; //无链表，确定元素存放位置，                    //扩容前的元素地址为 (oldCap - 1) &amp; e.hash ,所以这里的新的地址只有两种可能，一是地址不变，                    //二是变为 老位置+oldCap                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else { // preserve order                        Node&lt;K,V&gt; loHead = null, loTail = null;                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;/* 这里如果判断成立，那么该元素的地址在新的数组中就不会改变。因为oldCap的最高位的1，在e.hash对应的位上为0，所以扩容后得到的地址是一样的，位置不会改变 ，在后面的代码的执行中会放到loHead中去，最后赋值给newTab[j]；如果判断不成立，那么该元素的地址变为 原下标位置+oldCap，也就是lodCap最高位的1，在e.hash对应的位置上也为1，所以扩容后的地址改变了，在后面的代码中会放到hiHead中，最后赋值给newTab[j + oldCap]             举个栗子来说一下上面的两种情况：            设：oldCap=16 二进制为：0001 0000                oldCap-1=15 二进制为：0000 1111                e1.hash=10 二进制为：0000 1010                e2.hash=26 二进制为：0101 1010            e1在扩容前的位置为：e1.hash &amp; oldCap-1  结果为：0000 1010             e2在扩容前的位置为：e2.hash &amp; oldCap-1  结果为：0000 1010             结果相同，所以e1和e2在扩容前在同一个链表上，这是扩容之前的状态。    现在扩容后，需要重新计算元素的位置，在扩容前的链表中计算地址的方式为e.hash &amp; oldCap-1    那么在扩容后应该也这么计算呀，扩容后的容量为oldCap*2=32 0010 0000 newCap=32，新的计算    方式应该为    e1.hash &amp; newCap-1     即：0000 1010 &amp; 0001 1111     结果为0000 1010与扩容前的位置完全一样。    e2.hash &amp; newCap-1     即：0101 1010 &amp; 0001 1111     结果为0001 1010,为扩容前位置+oldCap。    而这里却没有e.hash &amp; newCap-1 而是 e.hash &amp; oldCap，其实这两个是等效的，都是判断倒数第五位    是0，还是1。如果是0，则位置不变，是1则位置改变为扩容前位置+oldCap。            再来分析下loTail loHead这两个的执行过程（假设(e.hash &amp; oldCap) == 0成立）：            第一次执行：            e指向oldTab[j]所指向的node对象，即e指向该位置上链表的第一个元素            loTail为空,所以loHead指向与e相同的node对象，然后loTail也指向了同一个node对象。            最后，在判断条件e指向next，就是指向oldTab链表中的第二个元素            第二次执行：            lotail不为null，所以lotail.next指向e，这里其实是lotail指向的node对象的next指向e，            也可以说是，loHead的next指向了e，就是指向了oldTab链表中第二个元素。此时loHead指向                    的node变成了一个长度为2的链表。然后lotail=e也就是指向了链表中第二个元素的地址。            第三次执行：            与第二次执行类似，loHead上的链表长度变为3，又增加了一个node，loTail指向新增的node               ......            hiTail与hiHead的执行过程与以上相同，这里就不再做解释了。            由此可以看出，loHead是用来保存新链表上的头元素的，loTail是用来保存尾元素的，直到遍                        历完链表。   这是(e.hash &amp; oldCap) == 0成立的时候。            (e.hash &amp; oldCap) == 0不成立的情况也相同，其实就是把oldCap遍历成两个新的链表，            通过loHead和hiHead来保存链表的头结点，然后将两个头结点放到newTab[j]与             newTab[j+oldCap]上面去      */                              do {                                next = e.next;                            if ((e.hash &amp; oldCap) == 0) {                                  if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }                        } while ((e = next) != null);                        if (loTail != null) {                            loTail.next = null;   //尾节点的next设置为空                            newTab[j] = loHead;                        }                        if (hiTail != null) {                            hiTail.next = null;   //尾节点的next设置为空                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }</code></pre><p>有关 JDK1.7 扩容出现的死循环的问题:</p><pre><code>/*** Transfers all entries from current table to newTable.*/void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) {   Entry&lt;K,V&gt; e = src[j];   if (e != null) {       src[j] = null;       do {           // B线程执行到这里之后就暂停了           Entry&lt;K,V&gt; next = e.next;           int i = indexFor(e.hash, newCapacity);           e.next = newTable[i];           newTable[i] = e;           e = next;       } while (e != null);   } }}</code></pre><p>并发下的 Rehash</p><p>　　1）假设我们有两个线程。我用红色和浅蓝色标注了一下。我们再回头看一下我们的 transfer 代码中的这个细节：</p><pre><code>do {    Entry&lt;K,V&gt; next = e.next; // &lt;--假设线程一执行到这里就被调度挂起了    int i = indexFor(e.hash, newCapacity);    e.next = newTable[i];    newTable[i] = e;    e = next;} while (e != null);</code></pre><p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p><p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092302379-1053929400.png" alt=""></p><p>注意，因为 Thread1 的 e 指向了 key(3)，而 next 指向了 key(7)，其在线程二 rehash 后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。</p><p>2）线程一被调度回来执行。</p><ul><li>先是执行 newTalbe[i] = e;</li><li>然后是 e = next，导致了 e 指向了 key(7)，</li><li>而下一次循环的 next = e.next 导致了 next 指向了 key(3)</li></ul><p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092343072-1415757438.png" alt=""></p><p>3）一切安好。</p><p>线程一接着工作。把 key(7) 摘下来，放到 newTable[i] 的第一个，然后把 e 和 next 往下移。</p><p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092412353-1913638098.png" alt=""></p><p>4）环形链接出现。</p><p>e.next = newTable[i] 导致  key(3).next 指向了 key(7)</p><p>注意：此时的 key(7).next 已经指向了 key(3)， 环形链表就这样出现了。</p><p> <img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092444871-1558486337.png" alt=""></p><p> 于是，当我们的线程一调用到，HashTable.get(11) 时，悲剧就出现了——Infinite Loop。</p><p>因为 HashMap 本来就不支持并发。要并发就用 ConcurrentHashmap</p><h4 id="HashMap-的-get-方法"><a href="#HashMap-的-get-方法" class="headerlink" title="HashMap 的 get() 方法"></a>HashMap 的 get() 方法</h4><pre><code>public V get(Object key) {    Node&lt;K,V&gt; e;    //直接调用了getNode()    return (e = getNode(hash(key), key)) == null ? null : e.value;}</code></pre><pre><code>final Node&lt;K,V&gt; getNode(int hash, Object key) {      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;     //先判断数组是否为空，长度是否大于0，那个node节点是否存在     if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;          (first = tab[(n - 1) &amp; hash]) != null) {          //如果找到，直接返回          if (first.hash == hash &amp;&amp; // always check first node              ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))              return first;         if ((e = first.next) != null) {             //如果是红黑树，去红黑树找             if (first instanceof TreeNode)                 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);             //链表找             do {                 if (e.hash == hash &amp;&amp;                     ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                     return e;             } while ((e = e.next) != null);         }     }     return null; }</code></pre><p>这里关于<code>first = tab[(n - 1) &amp; hash]</code></p><p>这里通过<code>(n - 1)&amp; hash</code>即可算出桶的在桶数组中的位置，可能有的朋友不太明白这里为什么这么做，这里简单解释一下。HashMap 中桶数组的大小 length 总是 2 的幂，此时，<code>(n - 1) &amp; hash</code> 等价于对 length 取余。但取余的计算效率没有位运算高，所以<code>(n - 1) &amp; hash</code>也是一个小的优化。举个例子说明一下吧，假设 hash = 185，n = 16。计算过程示意图如下</p><p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906095115131-234992109.png" alt=""></p><p> 在上面源码中，除了查找相关逻辑，还有一个计算 hash 的方法。这个方法源码如下：</p><pre><code>/** * 计算键的 hash 值 */static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>看这个方法的逻辑好像是通过位运算重新计算 hash，那么这里为什么要这样做呢？为什么不直接用键的 hashCode 方法产生的 hash 呢？大家先可以思考一下，我把答案写在下面。</p><p>这样做有两个好处，我来简单解释一下。我们再看一下上面求余的计算图，图中的 hash 是由键的 hashCode 产生。计算余数时，由于 n 比较小，hash 只有低 4 位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以上图中的 hash 高 4 位数据与低 4 位数据进行异或运算，即 <code>hash ^ (hash &gt;&gt;&gt; 4)</code>。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。此时的计算过程如下：</p><p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906095432574-555473243.png" alt=""></p><p>在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前 16 位为高位，后 16 位为低位，所以要右移 16 位。</p><p>上面所说的是重新计算 hash 的一个好处，除此之外，重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因了。</p><p>由于个人能力问题, 先学习这些, 数据结构这个大山, 我一定要刨平它。</p><p>基于 jdk1.7 版本的 HashMap</p><p><a href="https://www.jianshu.com/p/dde9b12343c1" target="_blank" rel="noopener">https://www.jianshu.com/p/dde9b12343c1</a></p><p>参考博客:</p><p><a href="https://www.cnblogs.com/wenbochang/archive/2018/02/22/8458756.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenbochang/archive/2018/02/22/8458756.html</a></p><p><a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722</a></p><p><a href="https://blog.csdn.net/pange1991/article/details/82377980" target="_blank" rel="noopener">https://blog.csdn.net/pange1991/article/details/82377980</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 面试必问的数据结构相关知识总结</title>
      <link href="/2020/07/10/HashMap%20%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/10/HashMap%20%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://www.cnblogs.com/Young111/p/11519952.html" target="_blank" rel="noopener">www.cnblogs.com</a></p></blockquote><h4 id="1-HashMap-的数据结构？"><a href="#1-HashMap-的数据结构？" class="headerlink" title="1.HashMap 的数据结构？"></a>1.HashMap 的数据结构？</h4><p>​        哈希表结构（链表散列：数组 + 链表）实现，结合数组和链表的优点。当链表长度超过 8 时，链表转换为红黑树。<br>transient Node&lt;K,V&gt;[] table;</p><h4 id="2-HashMap-的工作原理？"><a href="#2-HashMap-的工作原理？" class="headerlink" title="2.HashMap 的工作原理？"></a>2.HashMap 的工作原理？</h4><p>　　HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry&lt;K,V&gt; 接口）实现，HashMap 通过 put &amp; get 方法存储和获取。</p><p>存储对象时，将 K/V 键值传给 put() 方法：</p><p>​    ①、调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；</p><p>​    ②、调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容 resize 为 2n）；  </p><p>​    ③、如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；<br> 　　   如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；<br>　　    如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中。</p><p>（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）<br>（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）</p><p>　　获取对象时，将 K 传给 get() 方法：<br>　　①、调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；<br>　　②、顺序遍历链表，equals() 方法查找相同 Node 链表中 K 值对应的 V 值。</p><p>hashCode 是定位的，找到存储位置；equals 是定性的，比较两者是否相等。</p><h4 id="3-当两个对象的-hashCode-相同会发生什么？"><a href="#3-当两个对象的-hashCode-相同会发生什么？" class="headerlink" title="3. 当两个对象的 hashCode 相同会发生什么？"></a>3. 当两个对象的 hashCode 相同会发生什么？</h4><p>　　因为 hashCode 相同，不一定就是相等的（equals 方法比较），如果两个对象所在数组的下标相同，”碰撞” 就此发生。又因为 HashMap 使用链表存储对象，这个 Node 会存储到链表中。</p><h4 id="4-你知道-hash-的实现吗？为什么要这样实现？"><a href="#4-你知道-hash-的实现吗？为什么要这样实现？" class="headerlink" title="4. 你知道 hash 的实现吗？为什么要这样实现？"></a>4. 你知道 hash 的实现吗？为什么要这样实现？</h4><p>　　JDK 1.8 中，是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。</p><h4 id="5-为什么要用异或运算符？"><a href="#5-为什么要用异或运算符？" class="headerlink" title="5. 为什么要用异或运算符？"></a>5. 为什么要用异或运算符？</h4><p>​        保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。</p><h4 id="6-HashMap-的-table-的容量如何确定？loadFactor-是什么？-该容量如何变化？这种变化会带来什么问题？"><a href="#6-HashMap-的-table-的容量如何确定？loadFactor-是什么？-该容量如何变化？这种变化会带来什么问题？" class="headerlink" title="6. HashMap 的 table 的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？"></a>6. HashMap 的 table 的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？</h4><p>​        ①、table 数组大小是由capacity这个参数确定的，默认是 16，也可以构造时传入，最大限制是 1&lt;&lt;30；  </p><p>​        ②、loadFactor 是装载因子，主要目的是用来确认 table 数组是否需要动态扩展，默认值是 0.75，比如 table 数组大小为 16，装载               因子为 0.75 时，threshold 就是 12，当 table 的实际大小超过 12 时，table 就需要动态扩容；  </p><p>​        ③、扩容时，调用 resize() 方法，将 table 长度变为原来的两倍（注意是 table 长度，而不是 threshold）  </p><p>​        ④、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。</p><h4 id="7-HashMap-中-put-方法的过程？"><a href="#7-HashMap-中-put-方法的过程？" class="headerlink" title="7.HashMap 中 put 方法的过程？"></a>7.HashMap 中 put 方法的过程？</h4><ul><li>答：“调用哈希函数获取 Key 对应的 hash 值，再计算其数组下标；</li><li>如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；</li><li>如果链表长度超过阀值 (TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于 6，就把红黑树转回链表;</li><li>如果结点的 key 已经存在，则替换其 value 即可；</li><li>如果集合中的键值对大于 12，调用 resize 方法进行数组扩容。”</li></ul><h4 id="8-数组扩容的过程？"><a href="#8-数组扩容的过程？" class="headerlink" title="8. 数组扩容的过程？"></a>8. 数组扩容的过程？</h4><p>　　创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标 + 旧数组的大小。</p><h4 id="9-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><a href="#9-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="9. 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"></a>9. 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</h4><p>​        之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持 “平衡” 是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于 8 的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h4 id="10-说说你对红黑树的见解？"><a href="#10-说说你对红黑树的见解？" class="headerlink" title="10. 说说你对红黑树的见解？"></a>10. 说说你对红黑树的见解？</h4><ul><li>1、每个节点非红即黑</li><li>2、根节点总是黑色的</li><li>3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li><li>4、每个叶子节点都是黑色的空节点（NIL 节点）</li><li>5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ul><h4 id="11-jdk8-中对-HashMap-做了哪些改变？"><a href="#11-jdk8-中对-HashMap-做了哪些改变？" class="headerlink" title="11.jdk8 中对 HashMap 做了哪些改变？"></a>11.jdk8 中对 HashMap 做了哪些改变？</h4><ul><li>在 java 1.8 中，如果链表的长度超过了 8，那么链表将转换为红黑树。（桶的数量必须大于 64，小于 64 的时候只会扩容）</li><li>发生 hash 碰撞时，java 1.7 会在链表的头部插入，而 java 1.8 会在链表的尾部插入</li><li>在 java 1.8 中，Entry 被 Node 替代 (换了一个马甲)。</li></ul><h4 id="12-HashMap，LinkedHashMap，TreeMap-有什么区别？"><a href="#12-HashMap，LinkedHashMap，TreeMap-有什么区别？" class="headerlink" title="12.HashMap，LinkedHashMap，TreeMap 有什么区别？"></a>12.HashMap，LinkedHashMap，TreeMap 有什么区别？</h4><p>　　HashMap 参考其他问题：<br>　　LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；<br>　　TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）</p><h4 id="13-HashMap-amp-TreeMap-amp-LinkedHashMap-使用场景？"><a href="#13-HashMap-amp-TreeMap-amp-LinkedHashMap-使用场景？" class="headerlink" title="13.HashMap &amp; TreeMap &amp; LinkedHashMap 使用场景？"></a>13.HashMap &amp; TreeMap &amp; LinkedHashMap 使用场景？</h4><p>　　一般情况下，使用最多的是 HashMap。<br>　　HashMap：在 Map 中插入、删除和定位元素时；<br>　　TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；<br>　　LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。</p><h4 id="14-HashMap-和-HashTable-有什么区别？"><a href="#14-HashMap-和-HashTable-有什么区别？" class="headerlink" title="14.HashMap 和 HashTable 有什么区别？"></a>14.HashMap 和 HashTable 有什么区别？</h4><p>　　①、HashMap 是线程不安全的，HashTable 是线程安全的；<br>　　②、由于线程安全，所以 HashTable 的效率比不上 HashMap；<br>　　③、HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null，而 HashTable 不允许；<br>　　④、HashMap 默认初始化数组的大小为 16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍 + 1；<br>　　⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</p><h4 id="15-Java-中的另一个线程安全的与-HashMap-极其类似的类是什么？同样是线程安全，它与-HashTable-在线程同步上有什么不同？"><a href="#15-Java-中的另一个线程安全的与-HashMap-极其类似的类是什么？同样是线程安全，它与-HashTable-在线程同步上有什么不同？" class="headerlink" title="15.Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？"></a>15.Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？</h4><p>　　ConcurrentHashMap 类（是 Java 并发包 java.util.concurrent 中提供的一个线程安全且高效的 HashMap 实现）。<br>　　HashTable 是使用 synchronize 关键字加锁的原理（就是对对象加锁）；<br>　　而针对 ConcurrentHashMap，在 JDK 1.7 中采用 分段锁的方式；JDK 1.8 中直接采用了 CAS（无锁算法）+ synchronized。</p><h4 id="16-HashMap-amp-ConcurrentHashMap-的区别？"><a href="#16-HashMap-amp-ConcurrentHashMap-的区别？" class="headerlink" title="16.HashMap &amp; ConcurrentHashMap 的区别？"></a>16.HashMap &amp; ConcurrentHashMap 的区别？</h4><p>　　除了加锁，原理上无太大区别。另外，HashMap 的键值对允许有 null，但是 ConCurrentHashMap 都不允许。</p><h4 id="17-为什么-ConcurrentHashMap-比-HashTable-效率要高？"><a href="#17-为什么-ConcurrentHashMap-比-HashTable-效率要高？" class="headerlink" title="17. 为什么 ConcurrentHashMap 比 HashTable 效率要高？"></a>17. 为什么 ConcurrentHashMap 比 HashTable 效率要高？</h4><p>　　HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；</p><p>　　ConcurrentHashMap </p><ul><li>JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。</li><li>JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结点）（实现 Map.Entry&lt;K,V&gt;）。锁粒度降低了。</li></ul><h4 id="18-针对-ConcurrentHashMap-锁机制具体分析（JDK-1-7-VS-JDK-1-8）？"><a href="#18-针对-ConcurrentHashMap-锁机制具体分析（JDK-1-7-VS-JDK-1-8）？" class="headerlink" title="18. 针对 ConcurrentHashMap 锁机制具体分析（JDK 1.7 VS JDK 1.8）？"></a>18. 针对 ConcurrentHashMap 锁机制具体分析（JDK 1.7 VS JDK 1.8）？</h4><p>　　JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组 + 链表的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。<br>　　　　①、Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；<br>　　　　②、HashEntry 用来封装映射表的键 - 值对；<br>　　　　③、每个桶是由若干个 HashEntry 对象链接起来的链表</p><p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190914193055199-705993926.png" alt=""></p><p>　　JDK 1.8 中，采用 Node + CAS + Synchronized 来保证并发安全。取消类 Segment，直接用 table 数组存储键值对；当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD 时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树。</p><p><img src="http://upload-images.jianshu.io/upload_images/7779232-1e8ed39548081a1f.png" alt=""></p><h4 id="19-ConcurrentHashMap-在-JDK-1-8-中，为什么要使用内置锁-synchronized-来代替重入锁-ReentrantLock？"><a href="#19-ConcurrentHashMap-在-JDK-1-8-中，为什么要使用内置锁-synchronized-来代替重入锁-ReentrantLock？" class="headerlink" title="19.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？"></a>19.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？</h4><p>​        ①、粒度降低了；<br>​        ②、JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized 优化空间更大，更加自然。<br>​        ③、在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。</p><h4 id="20-ConcurrentHashMap-简单介绍？"><a href="#20-ConcurrentHashMap-简单介绍？" class="headerlink" title="20.ConcurrentHashMap 简单介绍？"></a>20.ConcurrentHashMap 简单介绍？</h4><p>①、重要的常量：<br>　　private transient volatile int sizeCtl;<br>　　当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；<br>　　当为 0 时，表示 table 还没有初始化；<br>　　当为其他正数时，表示初始化或者下一次进行扩容的大小。</p><p>②、数据结构：<br>　　Node 是存储结构的基本单元，继承 HashMap 中的 Entry，用于存储数据；<br>　　TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；<br>　　TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。</p><p>③、存储对象时（put() 方法）：<br>　　1. 如果没有初始化，就调用 initTable() 方法来进行初始化；<br>　　2. 如果没有 hash 冲突就直接 CAS 无锁插入；<br>　　3. 如果需要扩容，就先进行扩容；<br>　　4. 如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；<br>　　5. 如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环<br>　　6. 如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。</p><p>④、扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。<br>　　helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。</p><p>⑤、获取对象时（get() 方法）：<br>　　1. 计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；<br>　　2. 如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find() 方法，查找该结点，匹配就返回；<br>　　3. 以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。</p><h4 id="21-ConcurrentHashMap-的并发度是什么？"><a href="#21-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="21.ConcurrentHashMap 的并发度是什么？"></a>21.ConcurrentHashMap 的并发度是什么？</h4><p>　　程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小 2 幂指数作为实际并发度（假如用户设置并发度为 17，实际并发度则为 32）</p><p>有时间会对 HashTable，ConcurrentHashmap 解析。</p><h4 id="22-为什么要重写hashcode和equals方法？"><a href="#22-为什么要重写hashcode和equals方法？" class="headerlink" title="22.为什么要重写hashcode和equals方法？"></a>22.为什么要重写hashcode和equals方法？</h4><p>​        用HashMap存入自定义的类时，如果不重写这个自定义类的hashcode和equals方法，得到的结果会和预期的不一样。</p><p>​        重写hashcode和equals方法，来覆盖Object里的同名方法。Object的固有方法是根据两个对象的内存地址来判断，两个不同的对象，内存地址一定不会相同，所以无论值是否相等，结果都一定不会相等</p><p>参考博客：<br><a href="https://www.cnblogs.com/heqiyoujing/p/11143298.html" target="_blank" rel="noopener">https://www.cnblogs.com/heqiyoujing/p/11143298.html</a></p><p><a href="https://www.jianshu.com/p/75adf47958a7" target="_blank" rel="noopener">https://www.jianshu.com/p/75adf47958a7</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈HashMap</title>
      <link href="/2020/07/10/%E6%B5%85%E8%B0%88HashMap/"/>
      <url>/2020/07/10/%E6%B5%85%E8%B0%88HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><ul><li>什么是哈希表</li><li>HashMap的实现原理</li><li>为何HashMap的数组长度一定是2的次幂</li><li>重写equals方法需同时重写hashCode方法</li><li>JDK1.8中HashMap的性能优化  </li></ul><p>参考自：<a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464" target="_blank" rel="noopener">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p><h4 id="1-什么是哈希表"><a href="#1-什么是哈希表" class="headerlink" title="1.什么是哈希表"></a>1.什么是哈希表</h4><p>讨论哈希表之前，先大概了解下其他数据结构</p><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>采用一段连续的存储单元来存储数据。</p><p>通过指定下标查找，时间复杂度为O(1)；</p><p>通过给定值查找，需要遍历数组，逐一对比给定关键字和数组元素，时间复杂度O(n)。</p><p>对于有序数组，则可采用二分查找、插值查找、斐波那契查找等方式，可将复杂度提高到O(logn)；一般的插入删除操作，涉及到数组元素的移动，评价复杂度也为O(n)。</p><h5 id="线性链表"><a href="#线性链表" class="headerlink" title="线性链表"></a>线性链表</h5><p>对于链表的新增、删除等操作，在找到指定操作位置后，仅需处理结点间的引用即可，时间复杂度为O(1),而查找操作需要遍历链表逐一进行对比，复杂度为O(n)。</p><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>对一棵相对平衡的有序二叉树，CRUD，平均复杂度均为O(logn)。</p><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>哈希表(hash table)进行CRUD，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。</p><p>数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构。栈、队列、树、图等都是从逻辑结构去抽象，映射到内存中，也是这两种物理组织形式。</p><p>哈希表主干是数组。<br>如果要新增或查找某个元素，把元素的关键字，通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可以完成。这个函数可以简单描述为：存储位置=f(关键字)。函数f一般成为哈希函数，直接影响到哈希表的优劣。</p><h5 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h5><p>如果两个不同的元素，通过哈希函数得出的实际存储地址相同；或者元素哈希运算得到一个存储地址，进行插入的时候发现已经被其他元素占用了，这就是所谓的哈希冲突，也叫哈希碰撞。 </p><p>好的哈希函数会尽可能使计算简单和散列地址分布均匀。但是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。  </p><p>哈希冲突的解决方案有多种：开放定址法(发生冲突，继续寻找下一块未被占用的存储地址)、再散列函数法、链地址法。HashMap采用的即是链地址法，也就是数组+链表的方式。 </p><h4 id="2-HashMap的实现原理"><a href="#2-HashMap的实现原理" class="headerlink" title="2.HashMap的实现原理"></a>2.HashMap的实现原理</h4><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓的Map就是保存了两个对象之间的映射关系的一种集合）。</p><pre><code>//主干是一个Entry数组，初始值为空数组，长度一定是2的次幂transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPty_TABLE;</code></pre><p>Entry是HashMap中的一个静态内部类。代码如下:</p><pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final K key;    V value;    //存储执向下一个Entry的引用，单链表结构    Entry&lt;K,V&gt; next;     //对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算    int hash;     //creats new entry    Entry(int h, k K, V v, Entry&lt;K,V&gt; n) {        value = v;        next = n;        key = k;        hash = h;    }</code></pre><h6 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h6><p>HashMap由数组+链表组成，Entry数组是HashMap的主体，链表用于解决哈希冲突。如果定位到的数组位置不含链表(当前entry的next指向null)，那么CRUD很快，O(1)，仅需一次寻址即可；如果定位到的数组包含链表，添加操作，复杂度O(n)，先遍历链表，存在即覆盖，否则新增；查找操作，仍需遍历链表，然后通过key对象的equals方法逐一对比查找。所以，HashMap中的链表出现越少，性能越好。 </p><h6 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h6><p>HashMap的4个构造器size、threshold、loadFactor、modCount</p><pre><code>//实际存储key-value键值对的个数transient int size;//阈值，当table == {}时，该值为初始容量(默认16)//当table被填充了，也就是为table分配内存空间后，threshold一般为capacity*loadFactory//HashMap在进行扩容时需要参考thresholdint threshold;//负载因子，代表了table的填充度，默认是0.75//负载因子存在的原因，还是为了减缓哈希冲突//如果初始桶为16，等到满16个才扩容，某些桶可能就有不止一个元素了//所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32final float loadFactor;//HashMap被改变的次数//由于HashMap非线程安全，在对HashMap进行迭代时，如果其他线程的参与导致HashMap的结构发生了变化(put、remove等操作)，需要抛出异常ConcurrentModificationExceptiontransient int modeCount;</code></pre><p>示例代码:</p><pre><code>public HashMap(int initialCapacity, float loadFactor) {　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;        threshold = initialCapacity;　　　　　        //init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现        init();    }</code></pre><p>从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组  </p><h6 id="put"><a href="#put" class="headerlink" title="put"></a>put</h6><p>put操作的实现:</p><pre><code>public V put(K key, V value) {        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，        //此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)        if (table == EMPTY_TABLE) {            inflateTable(threshold);        }       //如果key为null，存储位置为table[0]或table[0]的冲突链上        if (key == null)            return putForNullKey(value);        int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀        int i = indexFor(hash, table.length);//获取在table中的实际位置        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value            Object k;            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {                V oldValue = e.value;                e.value = value;                e.recordAccess(this);                return oldValue;            }        }        modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败        addEntry(hash, key, value, i);//新增一个entry        return null;    }</code></pre><p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32。</p><pre><code>private void inflateTable(int toSize) {        //capacity一定是2的次幂        int capacity = roundUpToPowerOf2(toSize);        //此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，        //capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1         threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);        table = new Entry[capacity];        initHashSeedAsNeeded(capacity);    }</code></pre><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值</p><pre><code> private static int roundUpToPowerOf2(int number) {        // assert number &gt;= 0 : &quot;number must be non-negative&quot;;        return number &gt;= MAXIMUM_CAPACITY                ? MAXIMUM_CAPACITY                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;    }</code></pre><p>hash函数:</p><pre><code>//这是一个神奇的函数，用了很多的异或，移位等运算//对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀final int hash(Object k) {        int h = hashSeed;        if (0 != h &amp;&amp; k instanceof String) {            return sun.misc.Hashing.stringHash32((String) k);        }        h ^= k.hashCode();        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);    }</code></pre><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p><pre><code>    //返回数组下标    static int indexFor(int h, int length) {        return h &amp; (length-1);    }</code></pre><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为index=2。位运算对计算机来说，性能更高一些（HashMap中有大量位运算）  </p><p>所以最终存储位置的确定流程是这样的：</p><pre><code>    hashCode()              hash()      indexFor()key ----------&gt; hashcode ----------&gt; h ------------&gt;  存储下标                                        h&amp;(length-1)</code></pre><p>再来看看addEntry的实现：</p><pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {            //当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容            resize(2 * table.length);            hash = (null != key) ? hash(key) : 0;            bucketIndex = indexFor(hash, table.length);        }        createEntry(hash, key, value, bucketIndex);    }</code></pre><p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作</p><h4 id="3-为何HashMap的数组长度一定是2的次幂"><a href="#3-为何HashMap的数组长度一定是2的次幂" class="headerlink" title="3.为何HashMap的数组长度一定是2的次幂"></a>3.为何HashMap的数组长度一定是2的次幂</h4><p>我们来继续看上面提到的resize方法:</p><pre><code>void resize(int newCapacity) {        Entry[] oldTable = table;        int oldCapacity = oldTable.length;        if (oldCapacity == MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return;        }        Entry[] newTable = new Entry[newCapacity];        transfer(newTable, initHashSeedAsNeeded(newCapacity));        table = newTable;        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);    }</code></pre><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法:</p><pre><code>void transfer(Entry[] newTable, boolean rehash) {        int newCapacity = newTable.length;　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）        for (Entry&lt;K,V&gt; e : table) {            while(null != e) {                Entry&lt;K,V&gt; next = e.next;                if (rehash) {                    e.hash = null == e.key ? 0 : hash(e.key);                }                int i = indexFor(e.hash, newCapacity);                //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。                e.next = newTable[i];                newTable[i] = e;                e = next;            }        }    }</code></pre><p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀</p><p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p><p>如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p><h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><p>get方法:</p><pre><code> public V get(Object key) {　　　　 //如果key为null,则直接去table[0]处去检索即可。        if (key == null)            return getForNullKey();        Entry&lt;K,V&gt; entry = getEntry(key);        return null == entry ? null : entry.getValue(); }</code></pre><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。</p><p>我们再看一下getEntry方法:</p><pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {        if (size == 0) {            return null;        }        //通过key的hashcode值计算hash值        int hash = (key == null) ? 0 : hash(key);        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];             e != null;             e = e.next) {            Object k;            if (e.hash == hash &amp;&amp;                 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                return e;        }        return null;    }    </code></pre><p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p><h4 id="4-重写equals方法需同时重写hashCode方法"><a href="#4-重写equals方法需同时重写hashCode方法" class="headerlink" title="4.重写equals方法需同时重写hashCode方法"></a>4.重写equals方法需同时重写hashCode方法</h4><p>先来看下如果重写equals而不重写hashcode会发生什么:</p><pre><code>public class MyTest {    private static class Person{        int idCard;        String name;        public Person(int idCard, String name) {            this.idCard = idCard;            this.name = name;        }        @Override        public boolean equals(Object o) {            if (this == o) {                return true;            }            if (o == null || getClass() != o.getClass()){                return false;            }            Person person = (Person) o;            //两个对象是否等值，通过idCard来确定            return this.idCard == person.idCard;        }    }    public static void main(String []args){        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();        Person person = new Person(1234,&quot;乔峰&quot;);        //put到hashmap中去        map.put(person,&quot;天龙八部&quot;);        //get取出，从逻辑上讲应该能输出“天龙八部”        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));    }}实际输出结果：null</code></pre><p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null(也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到)  </p><p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同(只不过会发生哈希冲突，应尽量避免)</p><h4 id="5-JDK1-8中HashMap的性能优化"><a href="#5-JDK1-8中HashMap的性能优化" class="headerlink" title="5.JDK1.8中HashMap的性能优化"></a>5.JDK1.8中HashMap的性能优化</h4><p>假如一个数组槽位上链上数据过多（即拉链过长的情况）导致性能下降该怎么办？  </p><p>JDK1.8在JDK1.7的基础上针对增加了红黑树来进行优化。即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>九大常见数据结构</title>
      <link href="/2020/07/10/%E4%B9%9D%E5%A4%A7%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/10/%E4%B9%9D%E5%A4%A7%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://mp.weixin.qq.com/s/lnMvB3zgWZTmCfCvnNwTbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/lnMvB3zgWZTmCfCvnNwTbA</a></p><p>数据结构想必大家都不会陌生，对于一个成熟的程序员而言，熟悉和掌握数据结构和算法也是基本功之一。数据结构本身其实不过是数据按照特点关系进行存储或者组织的集合，特殊的结构在不同的应用场景中往往会带来不一样的处理效率。</p><p>常用的数据结构可根据数据访问的特点分为线性结构和非线性结构。线性结构包括常见的链表、栈、队列等，非线性结构包括树、图等。数据结构种类繁多，本文将通过图解的方式对常用的数据结构进行理论上的介绍和讲解，以方便大家掌握常用数据结构的基本知识。</p><h2 id="1-数组"><a href="#1-数组" class="headerlink" title=" 1  数组"></a> 1  数组</h2><p>数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。</p><h2 id="2-链表"><a href="#2-链表" class="headerlink" title=" 2  链表"></a> 2  链表</h2><p>链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。</p><p>这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。</p><p>一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p><h4 id="链表和数组对比"><a href="#链表和数组对比" class="headerlink" title="链表和数组对比"></a>链表和数组对比</h4><p>链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。链表和数组的异同点也是面试中高频的考察点之一。这里对单链表和数组的区别进行了对比和总结。</p><h2 id="3-跳表"><a href="#3-跳表" class="headerlink" title=" 3  跳表"></a> 3  跳表</h2><p>从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从 O(n) 提升至 O(logn)。  </p><p>跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前 redis 和 levelDB 都有用到跳表。</p><p>从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个 down 指针指向低一级的链表位置，这样才能实现跳跃查询的目的。</p><h2 id="4-栈"><a href="#4-栈" class="headerlink" title=" 4  栈"></a> 4  栈</h2><p>栈是一种比较简单的数据结构，常用一句话描述其特性，后进先出。栈本身是一种线性结构，但是在这个结构中只有一个口子允许数据的进出。这种模式可以参考腔肠动物… 即进食和排泄都用一个口…</p><p>栈的常用操作包括入栈 push 和出栈 pop，对应于数据的压入和压出。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理。</p><h2 id="5-队列"><a href="#5-队列" class="headerlink" title=" 5  队列"></a> 5  队列</h2><p>队列是栈的兄弟结构，与栈的后进先出相对应，队列是一种先进先出的数据结构。顾名思义，队列的数据存储是如同排队一般，先存入的数据先被压出。常与栈一同配合，可发挥最大的实力。</p><h2 id="6-树"><a href="#6-树" class="headerlink" title=" 6  树"></a> 6  树</h2><p>树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近 “倒挂的树”，因为它将根朝上，叶朝下。</p><p>树是图的一种，树与图的区别在于：树是没有环的，而图是可以有环的。</p><p>树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。</p><p>这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。</p><p>别看树好像很高级，其实可看作是链表的高配版。树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将 “链表” 竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。</p><p>树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为完全二叉树、满二叉树、平衡二叉树、红黑树等。</p><blockquote><p><strong>完全二叉树</strong>：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。</p></blockquote><blockquote><p><strong>满二叉树</strong>：除了最后一层，其它层的结点都有两个子结点。</p></blockquote><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树又被称为 AVL 树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p><blockquote><p><strong>二叉排序树</strong>：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。</p></blockquote><blockquote><p><strong>树的高度</strong>：结点层次的最大值</p></blockquote><blockquote><p><strong>平衡因子</strong>：左子树高度 - 右子树高度</p></blockquote><p>二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点 &lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。</p><p>（二叉树四种遍历方式[前序遍历、中序遍历、后序遍历、层序遍历] ）</p><p>平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p><p>平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有 LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR 和 RL 本质上只是 LL 和 RR 的组合。</p><blockquote><p>在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于 1 时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用<strong>单旋转</strong>进行平衡化，如果这三个结点位于一条折线上，则采用<strong>双旋转</strong>进行平衡化。</p></blockquote><p>左旋：S 为当前需要左旋的结点，E 为当前结点的父节点。</p><p>左旋的操作可以用一句话简单表示：将当前结点 S 的左孩子旋转为当前结点父结点 E 的右孩子，同时将父结点 E 旋转为当前结点 S 的左孩子。</p><p>右旋：S 为当前需要左旋的结点，E 为当前结点的父节点。右单旋是左单旋的镜像旋转。</p><p>左旋的操作同样可以用一句话简单表示：将当前结点 S 的左孩子 E 的右孩子旋转为当前结点 S 的左孩子，同时将当前结点 S 旋转为左孩子 E 的右孩子</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于 1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是 O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致 AVL 的插入和删除效率并不高。</p><p>为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。</p><p>红黑树具有五个特性：</p><blockquote><ol><li><p>每个结点要么是红的要么是黑的。</p></li><li><p>根结点是黑的。</p></li><li><p>每个叶结点（叶结点即指树尾端 NIL 指针或 NULL 结点）都是黑的。</p></li><li><p>如果一个结点是红的，那么它的两个儿子都是黑的。</p></li><li><p>对于任意结点而言，其到叶结点树尾端 NIL 指针的每条路径都包含相同数目的黑结点。</p></li></ol></blockquote><p>红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++ 中的 STL 就常用到红黑树作为底层的数据结构。</p><p>除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如 B 树、B + 树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒）</p><h4 id="B树（B-tree）"><a href="#B树（B-tree）" class="headerlink" title="B树（B-tree）"></a>B树（B-tree）</h4><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构。B树相对于平衡二叉树，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p><p>规则：</p><ol><li><p>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p></li><li><p>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p></li><li><p>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)；</p></li><li><p>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p></li></ol><p>查询：</p><p>如上图我要从上图中找到E字母，查找流程如下</p><ol><li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li><li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li><li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li></ol><p>插入：</p><ol><li>节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）；</li><li>排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</li></ol><p>删除：</p><ol><li>节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</li><li>满足节点本身比左边节点大，比右边节点小的排序规则;</li><li>关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；</li></ol><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。查找的效率要比B树更高、更稳定。</p><p>规则：</p><ol><li>B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</li><li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li><li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</li></ol><p>特点：</p><ol><li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li><li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li><li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li></ol><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h2 id="7-堆"><a href="#7-堆" class="headerlink" title="7  堆"></a>7  堆</h2><p>了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。</p><p>对于任意一个父节点的序号 n 来说（这里 n 从 0 算），它的子节点的序号一定是 2n+1，2n+2，因此可以直接用数组来表示一个堆。</p><p>不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p><p>堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK 问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选 topK 值的目的。</p><h2 id="8-散列表"><a href="#8-散列表" class="headerlink" title=" 8  散列表"></a> 8  散列表</h2><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个 x 值通过一个函数获得对应的一个 y 值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现 O(1) 的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。</p><p>散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：</p><blockquote><p><strong>直接寻址法</strong>：取关键字或关键字的某个线性函数值为散列地址。</p><p><strong>数字分析法</strong>：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</p><p><strong>平方取中**</strong>法**：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p><strong>取随机数法</strong>：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</p><p><strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</p></blockquote><p>确定好散列函数之后，通过某个<code>key</code>值的确会得到一个唯一的<code>value</code>地址。但是却会出现一些特殊情况。即通过不同的<code>key</code>值可能会访问到同一个地址，这个现象称之为冲突。</p><p>冲突在发生之后，当在对不同的<code>key</code>值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><blockquote><p><strong>开放地址法</strong>（也叫开放寻址法）：实际上就是当需要存储值时，对 Key 哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。</p><p><strong>再哈希法</strong>：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</p><p><strong>链地址法</strong>：链地址法其实就是对 Key 通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。</p><p><strong>公共溢出区</strong>：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</p></blockquote><p>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。</p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。  </p><p>考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。</p><h2 id="9-图"><a href="#9-图" class="headerlink" title=" 9  图"></a> 9  图</h2><p>图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。</p><p>图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为 1。此外根据边的方向性，还可将图分为有向图和无向图。</p><p>图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。</p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。</p><p>无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为 0。</p><p>有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。  </p><p>用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。</p><p>而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的 0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。</p><p>因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。</p><p>在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点 B 来说，其通过有向边可以到达顶点 A 和顶点 E，那么其对应的邻接表中的顺序即 B-&gt;A-&gt;E，其它顶点亦如此。</p><p>通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点 “指出去” 的信息，还包括从别的顶点 “指进来” 的信息。这里的 “指出去” 和“指进来”可以用出度和入度来表示。</p><blockquote><p>入度：有向图的某个顶点作为终点的次数和。</p><p>出度：有向图的某个顶点作为起点的次数和。</p></blockquote><p>由此看出，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><h4 id="逆邻接表"><a href="#逆邻接表" class="headerlink" title="逆邻接表"></a>逆邻接表</h4><p>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。</p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。</p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><blockquote><p><strong>data</strong>：用于存储该顶点中的数据；</p><p><strong>firstin 指针</strong>：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；</p><p><strong>firstout 指针</strong>：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点；</p></blockquote><p>边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><blockquote><p><strong>tailvex</strong>：用于存储作为弧尾的顶点的编号；</p><p><strong>headvex</strong>：用于存储作为弧头的顶点的编号；</p><p><strong>headlink</strong> <strong>指针</strong>：用于链接下一个存储作为弧头的顶点的节点；</p><p><strong>taillink</strong> <strong>指针</strong>：用于链接下一个存储作为弧尾的顶点的节点；</p></blockquote><p>以上图为例子，对于顶点 A 而言，其作为起点能够到达顶点 E。因此在邻接表中顶点 A 要通过边<code>AE</code>（即边 04）指向顶点 E，顶点 A 的<code>firstout</code>指针需要指向边 04 的<code>tailvex</code>。同时，从 B 出发能够到达 A，所以在逆邻接表中顶点 A 要通过边<code>AB</code>（即边 10）指向 B，顶点 A 的<code>firstin</code>指针需要指向边 10 的弧头，即<code>headlink</code>指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p><h2 id="10-总结"><a href="#10-总结" class="headerlink" title=" 10  总结"></a> 10  总结</h2><p>数据结构博大精深，没有高等数学的讳莫如深，也没有量子力学的玄乎其神，但是其在计算机科学的各个领域都具有强大的力量。本文试图采用图解的方式对九种数据结构进行理论上的介绍，但是其实这都是不够的。</p><p>即便是简单的数组、栈、队列等结构，在实际使用以及底层实现上都会有许多优化设计以及使用技巧，这意味着还需要真正把它们灵活的用起来，才能够算是真正意义上的熟悉和精通。但是本文可以作为常见数据结构的一个总结，当你对某些结构有些淡忘的时候，不妨重新回来看看。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的四种遍历方式</title>
      <link href="/2020/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://www.cnblogs.com/du001011/p/11229170.html" target="_blank" rel="noopener">www.cnblogs.com</a></p></blockquote><h3 id="二叉树的四种遍历方式："><a href="#二叉树的四种遍历方式：" class="headerlink" title="二叉树的四种遍历方式："></a>二叉树的四种遍历方式：</h3><ul><li>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问依次且仅被访问一次。<br>四种遍历方式分别为：先序遍历、中序遍历、后序遍历、层序遍历。</li><li><img src="https://img2018.cnblogs.com/blog/1542838/201907/1542838-20190722222821663-1408544995.png" alt=""></li></ul><h4 id="树的相关术语："><a href="#树的相关术语：" class="headerlink" title="树的相关术语："></a>树的相关术语：</h4><p>节点的度：一个节点含有的子树的个数称为该节点的度；</p><p>叶节点：度为0的节点；</p><p>树的度：一棵树中，最大的节点的度；</p><p>森林：由m（m&gt;=0）棵互不相交的树的集合</p><p>树的符号表现法：（1（2（4（5，6）），3）</p><p>解读：祖先1的子节点2（子节点4（叶节点5，6）），3。同层子树间用逗号隔开。</p><h4 id="如何创建二叉树"><a href="#如何创建二叉树" class="headerlink" title="如何创建二叉树"></a>如何创建二叉树</h4><p>遍历之前，我们首先介绍一下，如何创建一个二叉树，在这里我们用的是先建左树在建右树的方法，</p><p>首先要声明结点 TreeNode 类，代码如下：</p><pre><code>public class TreeNode {    public int data;    public TreeNode leftChild;    public TreeNode rightChild;    public TreeNode(int data){        this.data = data;    }}</code></pre><p>再来创建一颗二叉树：</p><pre><code>/**     * 构建二叉树     * @param list   输入序列     * @return     */    public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; list){        TreeNode node = null;        if(list == null || list.isEmpty()){            return null;        }        Integer data = list.removeFirst();        if(data!=null){            node = new TreeNode(data);            node.leftChild = createBinaryTree(list);            node.rightChild = createBinaryTree(list);        }        return node;    }</code></pre><p>接下来我们按照上面列的顺序一一讲解，</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>首先来看先序遍历，所谓的先序遍历就是先访问根节点，在访问左节点，最后访问右节点，</p><p><img src="https://img2018.cnblogs.com/blog/1542838/201907/1542838-20190722224917877-2136323533.png" alt=""></p><p>如上图所示，前序遍历结果为：ABDFECGHI</p><p>实现代码如下：</p><pre><code>/**     * 二叉树前序遍历   根-&gt; 左-&gt; 右     * @param node    二叉树节点     */    public static void preOrderTraveral(TreeNode node){        if(node == null){            return;        }        System.out.print(node.data+&quot; &quot;);        preOrderTraveral(node.leftChild);        preOrderTraveral(node.rightChild);    }</code></pre><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>再者就是中序遍历，所谓的中序遍历就是先访问左节点，再访问根节点，最后访问右节点，</p><p><img src="https://img2018.cnblogs.com/blog/1542838/201907/1542838-20190722225534764-1572433775.png" alt=""></p><p>如上图所示，中序遍历结果为：DBEFAGHCI（G没有左子树，所以直接访问G，而不是访问H）</p><p>实现代码如下：</p><pre><code>/**     * 二叉树中序遍历   左-&gt; 根-&gt; 右     * @param node   二叉树节点     */    public static void inOrderTraveral(TreeNode node){        if(node == null){            return;        }        inOrderTraveral(node.leftChild);        System.out.print(node.data+&quot; &quot;);        inOrderTraveral(node.rightChild);    }</code></pre><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>最后就是后序遍历，所谓的后序遍历就是先访问左节点，再访问右节点，最后访问根节点。</p><p><img src="https://img2018.cnblogs.com/blog/1542838/201907/1542838-20190722225822242-120610112.png" alt=""></p><p>如上图所示，前序遍历结果为：DEFBHGICA</p><p>实现代码如下：</p><pre><code>/**     * 二叉树后序遍历   左-&gt; 右-&gt; 根     * @param node    二叉树节点     */    public static void postOrderTraveral(TreeNode node){        if(node == null){            return;        }        postOrderTraveral(node.leftChild);        postOrderTraveral(node.rightChild);        System.out.print(node.data+&quot; &quot;);    }</code></pre><h3 id="非递归的前中后序遍历"><a href="#非递归的前中后序遍历" class="headerlink" title="非递归的前中后序遍历"></a>非递归的前中后序遍历</h3><p>讲完上面三种非递归的方法，下面再给大家讲讲非递归是如何实现前中后序遍历的</p><h4 id="非递归前序遍历"><a href="#非递归前序遍历" class="headerlink" title="非递归前序遍历"></a>非递归前序遍历</h4><p>还是一样，先看非递归前序遍历</p><ol><li>首先申请一个新的栈，记为 stack；</li><li>声明一个结点 treeNode，让其指向 node 结点；</li><li>如果 treeNode 的不为空，将 treeNode 的值打印，并将 treeNode 入栈，然后让 treeNode 指向 treeNode 的右结点，</li><li>重复步骤 3，直到 treenode 为空；</li><li>然后出栈，让 treeNode 指向 treeNode 的右孩子</li><li>重复步骤 3，直到 stack 为空.</li></ol><p>实现代码如下：</p><pre><code>public static void preOrderTraveralWithStack(TreeNode node){        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        while(treeNode!=null || !stack.isEmpty()){            //迭代访问节点的左孩子，并入栈            while(treeNode != null){                System.out.print(treeNode.data+&quot; &quot;);                stack.push(treeNode);                treeNode = treeNode.leftChild;            }            //如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子            if(!stack.isEmpty()){                treeNode = stack.pop();                treeNode = treeNode.rightChild;            }        }    }</code></pre><h4 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h4><p>中序遍历非递归，在此不过多叙述具体步骤了，</p><p>具体过程：</p><ol><li>申请一个新栈，记为 stack，申请一个变量 cur，初始时令 treeNode 为头节点；</li><li>先把 treeNode 节点压入栈中，对以 treeNode 节点为头的整棵子树来说，依次把整棵树的左子树压入栈中，即不断令 treeNode=treeNode.leftChild，然后重复步骤 2；</li><li>不断重复步骤 2，直到发现 cur 为空，此时从 stack 中弹出一个节点记为 treeNode，打印 node 的值，并让 treeNode= treeNode.right，然后继续重复步骤 2；</li><li>当 stack 为空并且 cur 为空时结束。</li></ol><pre><code>public static void inOrderTraveralWithStack(TreeNode node){        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        while(treeNode!=null || !stack.isEmpty()){            while(treeNode != null){                stack.push(treeNode);                treeNode = treeNode.leftChild;            }            if(!stack.isEmpty()){                treeNode = stack.pop();                System.out.print(treeNode.data+&quot; &quot;);                treeNode = treeNode.rightChild;            }        }    }</code></pre><h4 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h4><p>后序遍历这里较前两者实现复杂一点，我们需要一个标记为来记忆我们此时节点上一个节点，具体看代码注释</p><pre><code>public static void postOrderTraveralWithStack(TreeNode node){        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        TreeNode lastVisit = null;   //标记每次遍历最后一次访问的节点        while(treeNode!=null || !stack.isEmpty()){//节点不为空，结点入栈，并且指向下一个左孩子            while(treeNode!=null){                stack.push(treeNode);                treeNode = treeNode.leftChild;            }            //栈不为空            if(!stack.isEmpty()){                //出栈                treeNode = stack.pop();                /**                 * 这块就是判断treeNode是否有右孩子，                 * 如果没有输出treeNode.data，让lastVisit指向treeNode，并让treeNode为空                 * 如果有右孩子，将当前节点继续入栈，treeNode指向它的右孩子,继续重复循环                 */                if(treeNode.rightChild == null || treeNode.rightChild == lastVisit) {                    System.out.print(treeNode.data + &quot; &quot;);                    lastVisit = treeNode;                    treeNode  = null;                }else{                    stack.push(treeNode);                    treeNode = treeNode.rightChild;                }            }        }    }</code></pre><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>最后再介绍一下层序遍历</p><p>具体步骤如下：</p><ol><li>首先申请一个新的队列，记为 queue；</li><li>将头结点 head 压入 queue 中；</li><li>每次从 queue 中出队，记为 node，然后打印 node 值，如果 node 左孩子不为空，则将左孩子入队；如果 node 的右孩子不为空，则将右孩子入队；</li><li>重复步骤 3，直到 queue 为空。</li></ol><p>实现代码如下：</p><pre><code>public static void levelOrder(TreeNode root){        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.add(root);        while(!queue.isEmpty()){            root = queue.pop();            System.out.print(root.data+&quot; &quot;);            if(root.leftChild!=null) queue.add(root.leftChild);            if(root.rightChild!=null) queue.add(root.rightChild);        }    }</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

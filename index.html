<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>topone233</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="topone233">
<meta property="og:url" content="https://topone233.github.io/index.html">
<meta property="og:site_name" content="topone233">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="QSX1C">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="topone233" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">topone233</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://topone233.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-HashMap 剖析 (基于 jdk1.8)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/HashMap%20%E5%89%96%E6%9E%90%20(%E5%9F%BA%E4%BA%8E%20jdk1.8)/" class="article-date">
  <time datetime="2020-07-10T09:07:59.406Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/HashMap%20%E5%89%96%E6%9E%90%20(%E5%9F%BA%E4%BA%8E%20jdk1.8)/">HashMap 剖析 (基于 jdk1.8)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文地址 <a href="https://www.cnblogs.com/Young111/p/11471049.html" target="_blank" rel="noopener">www.cnblogs.com</a></p>
<p>本文的源码是基于 JDK1.8 版本，在学习 HashMap 之前，先了解数组和链表的知识。</p>
<p><strong>数组：</strong><br>数组具有遍历快，增删慢的特点。数组在堆中是一块连续的存储空间，遍历时数组的首地址是知道的（首地址 = 首地址 + 元素字节数 * 下标），所以遍历快（数组遍历的时间复杂度为 O(1) ）；增删慢是因为，当在中间插入或删除元素时，会造成该元素后面所有元素地址的改变，所以增删慢（增删的时间复杂度为 O(n) ）。</p>
<p><strong>链表：</strong><br>链表具有增删快，遍历慢的特点。链表中各元素的内存空间是不连续的，一个节点至少包含节点数据与后继节点的引用，所以在插入删除时，只需修改该位置的前驱节点与后继节点即可，链表在插入删除时的时间复杂度为 O(1)。但是在遍历时，get(n) 元素时，需要从第一个开始，依次拿到后面元素的地址，进行遍历，直到遍历到第 n 个元素（时间复杂度为 O(n) ），所以效率极低。</p>
<p><strong>HashMap:</strong><br>Hash 表是一个数组 + 链表的结构，这种结构能够保证在遍历与增删的过程中，如果不产生 hash 碰撞，仅需一次定位就可完成，时间复杂度能保证在 O(1)。  在 jdk1.7 中，只是单纯的数组 + 链表的结构，但是如果散列表中的 hash 碰撞过多时，会造成效率的降低，所以在 JKD1.8 中对这种情况进行了控制，当一个 hash 值上的链表长度大于 8 时，该节点上的数据就不再以链表进行存储，而是转成了一个红黑树。</p>
<p>红黑树:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>hash 碰撞：</strong><br>hash 是指，两个元素通过 hash 函数计算出的值是一样的，是同一个存储地址。当后面的元素要插入到这个地址时，发现已经被占用了，这时候就产生了 hash 冲突</p>
<p><strong>hash 冲突的解决方法：</strong><br>开放定址法 (查询产生冲突的地址的下一个地址是否被占用，直到寻找到空的地址)，再散列法，链地址法等。hashmap 采用的就是链地址法，jdk1.7 中，当冲突时，在冲突的地址上生成一个链表，将冲突的元素的 key，通过 equals 进行比较，相同即覆盖，不同则添加到链表上，此时如果链表过长，效率就会大大降低，查找和添加操作的时间复杂度都为 O(n)；但是在 jdk1.8 中如果链表长度大于 8，链表就会转化为红黑树，下图就是 1.8 版本的（图片来源 <a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722</a>），时间复杂度也降为了 O(logn)，性能得到了很大的优化。</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906090342350-1437652164.png" alt=""></p>
<p><strong>下面通过源码分析一下，HashMap 的底层实现</strong></p>
<p>首先，hashMap 的主干是一个 Node 数组（jdk1.7 及之前为 Entry 数组）每一个 Node 包含一个 key 与 value 的键值对，与一个 next 指向下一个 node，hashMap 由多个 Node 对象组成。</p>
<p>Node 是 HhaspMap 中的一个静态内部类 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">         final int hash;</span><br><span class="line">         final K key;</span><br><span class="line">         V value;</span><br><span class="line">         Node&lt;K,V&gt; next;</span><br><span class="line"> </span><br><span class="line">         Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">             this.key &#x3D; key;</span><br><span class="line">             this.value &#x3D; value;</span><br><span class="line">             this.next &#x3D; next;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         public final K getKey()        &#123; return key; &#125;</span><br><span class="line">         public final V getValue()      &#123; return value; &#125;</span><br><span class="line">         public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;hashCode等其他代码</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


<p>再看下 hashMap 中几个重要的字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认初始容量为16，0000 0001 左移4位 0001 0000为16，主干数组的初始容量为16，而且这个数组</span><br><span class="line">&#x2F;&#x2F;必须是2的倍数(后面说为什么是2的倍数)</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;最大容量为int的最大值除2</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;默认加载因子为0.75</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;阈值，如果主干数组上的链表的长度大于8，链表转化为红黑树</span><br><span class="line"> static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;hash表扩容后，如果发现某一个红黑树的长度小于6，则会重新退化为链表</span><br><span class="line"> static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;当hashmap容量大于64时，链表才能转成红黑树</span><br><span class="line"> static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;临界值&#x3D;主干数组容量*负载因子</span><br><span class="line">int threshold；</span><br></pre></td></tr></table></figure>


<p><strong>HashMap 的构造方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;initialCapacity为初始容量，loadFactor为负载因子</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始容量小于0，抛出非法数据异常</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#x2F;&#x2F;初始容量最大为MAXIMUM_CAPACITY</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F;负载因子必须大于0，并且是合法数字</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        </span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        &#x2F;&#x2F;将初始容量转成2次幂</span><br><span class="line">        this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;tableSizeFor的作用就是，如果传入A，当A大于0，小于定义的最大容量时，</span><br><span class="line">    &#x2F;&#x2F;如果A是2次幂则返回A，否则将A转化为一个比A大且差距最小的2次幂。  </span><br><span class="line">    &#x2F;&#x2F;例如传入7返回8，传入8返回8，传入9返回16</span><br><span class="line">  static final int tableSizeFor(int cap) &#123;</span><br><span class="line">        int n &#x3D; cap - 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;调用上面的构造方法，自定义初始容量，负载因子为默认的0.75</span><br><span class="line"> public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;默认构造方法，负载因子为0.75，初始容量为DEFAULT_INITIAL_CAPACITY&#x3D;16，初始容量在第一次put时才会初始化</span><br><span class="line"> public HashMap() &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;传入一个MAP集合的构造方法</span><br><span class="line"> public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>HashMap 的 put() 方法</strong></p>
<p>put 方法的源码分析是本篇的一个重点，因为通过该方法我们可以窥探到 HashMap 在内部是如何进行数据存储的，所谓的数组 + 链表 + 红黑树的存储结构是如何形成的，又是在何种情况下将链表转换成红黑树来优化性能的。带着一系列的疑问，我们看这个 put 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是 put 方法调用了 putVal 方法，其中传入一个参数位 hash(key)，我们首先来看看 hash() 这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此处如果传入的 int 类型的值：①向一个 Object 类型赋值一个 int 的值时，会将 int 值自动封箱为 Integer。②integer 类型的 hashcode 都是他自身的值，即 h=key；h &gt;&gt;&gt; 16 为无符号右移 16 位，低位挤走，高位补 0；^ 为按位异或，即转成二进制后，相异为 1，相同为 0，由此可发现，当传入的值小于  2 的 16 次方 - 1 时，调用这个方法返回的值，都是自身的值。<br>然后再执行 putVal 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;onlyIfAbsent是true的话，不要改变现有的值</span><br><span class="line">&#x2F;&#x2F;evict为true的话，表处于创建模式 </span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">&#x2F;&#x2F;如果主干上的table为空，长度为0，调用resize方法，调整table的长度（resize方法在下图中）</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            &#x2F;* 这里调用resize，其实就是第一次put时，对数组进行初始化。</span><br><span class="line">               如果是默认构造方法会执行resize中的这几句话：</span><br><span class="line">               newCap &#x3D; DEFAULT_INITIAL_CAPACITY;  新的容量等于默认值16</span><br><span class="line">               newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);            </span><br><span class="line">               threshold &#x3D; newThr;   临界值等于16*0.75</span><br><span class="line">               Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap]; </span><br><span class="line">               table &#x3D; newTab; 将新的node数组赋值给table，然后return newTab</span><br><span class="line">                </span><br><span class="line">                如果是自定义的构造方法则会执行resize中的： </span><br><span class="line">                int oldThr &#x3D; threshold;   </span><br><span class="line">                newCap &#x3D; oldThr;   新的容量等于threshold，这里的threshold都是2的倍数，原因在    </span><br><span class="line">                于传入的数都经过tableSizeFor方法，返回了一个新值，上面解释过</span><br><span class="line">                float ft &#x3D; (float)newCap * loadFactor; </span><br><span class="line">                newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                (int)ft : Integer.MAX_VALUE); </span><br><span class="line">                 threshold &#x3D; newThr; 新的临界值等于 (int)(新的容量*负载因子)</span><br><span class="line">                Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">                table &#x3D; newTab; return newTab;</span><br><span class="line">            *&#x2F;</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;  &#x2F;&#x2F;将调用resize后构造的数组的长度赋值给n</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#x2F;&#x2F;将数组长度与计算得到的hash值比较</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);&#x2F;&#x2F;位置为空，将i位置上赋值一个node对象</span><br><span class="line">        else &#123;  &#x2F;&#x2F;位置不为空</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;  &#x2F;&#x2F; 如果这个位置的old节点与new节点的key完全相同</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) </span><br><span class="line">                e &#x3D; p;             &#x2F;&#x2F; 则e&#x3D;p</span><br><span class="line">            else if (p instanceof TreeNode) &#x2F;&#x2F; 如果p已经是树节点的一个实例，既这里已经是树了</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;  &#x2F;&#x2F;p与新节点既不完全相同，p也不是treenode的实例</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;  &#x2F;&#x2F;一个死循环</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;   &#x2F;&#x2F;e&#x3D;p.next,如果p的next指向为null</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);  &#x2F;&#x2F;指向一个新的节点</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; 如果链表长度大于等于8</span><br><span class="line">                            treeifyBin(tab, hash);  &#x2F;&#x2F;将链表转为红黑树</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">       if (e.hash &#x3D;&#x3D; hash &amp;&amp;  &#x2F;&#x2F;如果遍历过程中链表中的元素与新添加的元素完全相同，则跳出循环</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e; &#x2F;&#x2F;将p中的next赋值给p,即将链表中的下一个node赋值给p，</span><br><span class="line">                           &#x2F;&#x2F;继续循环遍历链表中的元素</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F;这个判断中代码作用为：如果添加的元素产生了hash冲突，那么调用                </span><br><span class="line">                             &#x2F;&#x2F;put方法时，会将他在链表中他的上一个元素的值返回</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)  &#x2F;&#x2F;判断条件成立的话，将oldvalue替换        </span><br><span class="line">                &#x2F;&#x2F;为newvalue，返回oldvalue；不成立则不替换，然后返回oldvalue</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                afterNodeAccess(e);  &#x2F;&#x2F;这个方法在后面说</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;  &#x2F;&#x2F;记录修改次数</span><br><span class="line">        if (++size &gt; threshold)   &#x2F;&#x2F;如果元素数量大于临界值，则进行扩容</span><br><span class="line">            resize();   &#x2F;&#x2F;下面说</span><br><span class="line">        afterNodeInsertion(evict);  </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>在 Java 8 中，如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8)，就使用红黑树来替换链表，从而提高速度。上诉代码这个替换的方法叫 treeifyBin() 即树形化。</p>
<p>看一下 treeifyBin() 的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将桶内所有的 链表节点 替换成 红黑树节点</span><br><span class="line"> final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">   int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F;如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建&#x2F;扩容</span><br><span class="line">   if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果哈希表中的元素个数超过了 树形化阈值，进行树形化</span><br><span class="line">        &#x2F;&#x2F; e 是哈希表中指定位置桶里的链表节点，从第一个开始</span><br><span class="line">        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null; &#x2F;&#x2F;红黑树的头、尾节点</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;新建一个树形节点，内容和当前链表节点 e 一致</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">            if (tl &#x3D;&#x3D; null) &#x2F;&#x2F;确定树头节点</span><br><span class="line">                hd &#x3D; p;</span><br><span class="line">           else &#123;</span><br><span class="line">               p.prev &#x3D; tl;</span><br><span class="line">                tl.next &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl &#x3D; p;</span><br><span class="line">        &#125; while ((e &#x3D; e.next) !&#x3D; null); </span><br><span class="line">        &#x2F;&#x2F;让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span><br><span class="line">        if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>注释已经很详细了，咱们说一下这个初始化的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果 table 还未被初始化，那么初始化它</span><br><span class="line">if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">n &#x3D; (tab &#x3D; resize()).length;</span><br></pre></td></tr></table></figure>

<p>resize() 扩容机制，单元素如何散列到新的数组中，链表中的元素如何散列到新的数组中，红黑树中的元素如何散列到新的数组中？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;上图中说了默认构造方法与自定义构造方法第一次执行resize的过程，这里再说一下扩容的过程   </span><br><span class="line"> final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;  &#x2F;&#x2F;扩容肯定执行这个分支</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;   &#x2F;&#x2F;当容量超过最大值时，临界值设置为int最大值</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY) &#x2F;&#x2F;扩容容量为2倍，临界值为2倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; 不执行</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        else &#123;                &#x2F;&#x2F; 不执行</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 不执行</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold &#x3D; newThr;    &#x2F;&#x2F;将新的临界值赋值赋值给threshold</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;   &#x2F;&#x2F;新的数组赋值给table</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;扩容后，重新计算元素新的位置</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;   &#x2F;&#x2F;原数组</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;   &#x2F;&#x2F;通过原容量遍历原数组</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;   &#x2F;&#x2F;判断node是否为空，将j位置上的节点</span><br><span class="line">                &#x2F;&#x2F;保存到e,然后将oldTab置为空，这里为什么要把他置为空呢，置为空有什么好处吗？？</span><br><span class="line">                &#x2F;&#x2F;难道是吧oldTab变为一个空数组，便于垃圾回收？？ 这里不是很清楚</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)          &#x2F;&#x2F;判断node上是否有链表</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e; &#x2F;&#x2F;无链表，确定元素存放位置，</span><br><span class="line">                    &#x2F;&#x2F;扩容前的元素地址为 (oldCap - 1) &amp; e.hash ,所以这里的新的地址只有两种可能，一是地址不变，</span><br><span class="line">                    &#x2F;&#x2F;二是变为 老位置+oldCap</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line"> </span><br><span class="line">                      </span><br><span class="line">&#x2F;* 这里如果判断成立，那么该元素的地址在新的数组中就不会改变。因为oldCap的最高位的1，在e.hash对应的位上为0，所以扩容后得到的地址是一样的，位置不会改变 ，在后面的代码的执行中会放到loHead中去，最后赋值给newTab[j]；</span><br><span class="line">如果判断不成立，那么该元素的地址变为 原下标位置+oldCap，也就是lodCap最高位的1，在e.hash对应的位置上也为1，所以扩容后的地址改变了，在后面的代码中会放到hiHead中，最后赋值给newTab[j + oldCap]</span><br><span class="line">             举个栗子来说一下上面的两种情况：</span><br><span class="line">            设：oldCap&#x3D;16 二进制为：0001 0000</span><br><span class="line">                oldCap-1&#x3D;15 二进制为：0000 1111</span><br><span class="line">                e1.hash&#x3D;10 二进制为：0000 1010</span><br><span class="line">                e2.hash&#x3D;26 二进制为：0101 1010</span><br><span class="line">            e1在扩容前的位置为：e1.hash &amp; oldCap-1  结果为：0000 1010 </span><br><span class="line">            e2在扩容前的位置为：e2.hash &amp; oldCap-1  结果为：0000 1010 </span><br><span class="line">            结果相同，所以e1和e2在扩容前在同一个链表上，这是扩容之前的状态。</span><br><span class="line">            </span><br><span class="line">    现在扩容后，需要重新计算元素的位置，在扩容前的链表中计算地址的方式为e.hash &amp; oldCap-1</span><br><span class="line">    那么在扩容后应该也这么计算呀，扩容后的容量为oldCap*2&#x3D;32 0010 0000 newCap&#x3D;32，新的计算</span><br><span class="line">    方式应该为</span><br><span class="line">    e1.hash &amp; newCap-1 </span><br><span class="line">    即：0000 1010 &amp; 0001 1111 </span><br><span class="line">    结果为0000 1010与扩容前的位置完全一样。</span><br><span class="line">    e2.hash &amp; newCap-1 </span><br><span class="line">    即：0101 1010 &amp; 0001 1111 </span><br><span class="line">    结果为0001 1010,为扩容前位置+oldCap。</span><br><span class="line">    而这里却没有e.hash &amp; newCap-1 而是 e.hash &amp; oldCap，其实这两个是等效的，都是判断倒数第五位</span><br><span class="line">    是0，还是1。如果是0，则位置不变，是1则位置改变为扩容前位置+oldCap。</span><br><span class="line">            再来分析下loTail loHead这两个的执行过程（假设(e.hash &amp; oldCap) &#x3D;&#x3D; 0成立）：</span><br><span class="line">            第一次执行：</span><br><span class="line">            e指向oldTab[j]所指向的node对象，即e指向该位置上链表的第一个元素</span><br><span class="line">            loTail为空,所以loHead指向与e相同的node对象，然后loTail也指向了同一个node对象。</span><br><span class="line">            最后，在判断条件e指向next，就是指向oldTab链表中的第二个元素</span><br><span class="line">            第二次执行：</span><br><span class="line">            lotail不为null，所以lotail.next指向e，这里其实是lotail指向的node对象的next指向e，</span><br><span class="line">            也可以说是，loHead的next指向了e，就是指向了oldTab链表中第二个元素。此时loHead指向        </span><br><span class="line">            的node变成了一个长度为2的链表。然后lotail&#x3D;e也就是指向了链表中第二个元素的地址。</span><br><span class="line">            第三次执行：</span><br><span class="line">            与第二次执行类似，loHead上的链表长度变为3，又增加了一个node，loTail指向新增的node</span><br><span class="line">               ......</span><br><span class="line">            hiTail与hiHead的执行过程与以上相同，这里就不再做解释了。</span><br><span class="line">            由此可以看出，loHead是用来保存新链表上的头元素的，loTail是用来保存尾元素的，直到遍            </span><br><span class="line">            历完链表。   这是(e.hash &amp; oldCap) &#x3D;&#x3D; 0成立的时候。</span><br><span class="line">            (e.hash &amp; oldCap) &#x3D;&#x3D; 0不成立的情况也相同，其实就是把oldCap遍历成两个新的链表，</span><br><span class="line">            通过loHead和hiHead来保存链表的头结点，然后将两个头结点放到newTab[j]与 </span><br><span class="line">            newTab[j+oldCap]上面去      </span><br><span class="line">*&#x2F;</span><br><span class="line">                              do &#123;</span><br><span class="line">                                next &#x3D; e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;   &#x2F;&#x2F;尾节点的next设置为空</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;   &#x2F;&#x2F;尾节点的next设置为空</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>有关 JDK1.7 扩容出现的死循环的问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Transfers all entries from current table to newTable.</span><br><span class="line">*&#x2F;</span><br><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line"> Entry[] src &#x3D; table;</span><br><span class="line"> int newCapacity &#x3D; newTable.length;</span><br><span class="line"> for (int j &#x3D; 0; j &lt; src.length; j++) &#123;</span><br><span class="line">   Entry&lt;K,V&gt; e &#x3D; src[j];</span><br><span class="line">   if (e !&#x3D; null) &#123;</span><br><span class="line">       src[j] &#x3D; null;</span><br><span class="line">       do &#123;</span><br><span class="line">           &#x2F;&#x2F; B线程执行到这里之后就暂停了</span><br><span class="line">           Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">           int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">           e.next &#x3D; newTable[i];</span><br><span class="line">           newTable[i] &#x3D; e;</span><br><span class="line">           e &#x3D; next;</span><br><span class="line">       &#125; while (e !&#x3D; null);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>并发下的 Rehash</p>
<p>　　1）假设我们有两个线程。我用红色和浅蓝色标注了一下。我们再回头看一下我们的 transfer 代码中的这个细节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; next &#x3D; e.next; &#x2F;&#x2F; &lt;--假设线程一执行到这里就被调度挂起了</span><br><span class="line"></span><br><span class="line">    int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line"></span><br><span class="line">    e.next &#x3D; newTable[i];</span><br><span class="line"></span><br><span class="line">    newTable[i] &#x3D; e;</span><br><span class="line"></span><br><span class="line">    e &#x3D; next;</span><br><span class="line"></span><br><span class="line">&#125; while (e !&#x3D; null);</span><br></pre></td></tr></table></figure>


<p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092302379-1053929400.png" alt=""></p>
<p>注意，因为 Thread1 的 e 指向了 key(3)，而 next 指向了 key(7)，其在线程二 rehash 后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。</p>
<p>2）线程一被调度回来执行。</p>
<ul>
<li>先是执行 newTalbe[i] = e;</li>
<li>然后是 e = next，导致了 e 指向了 key(7)，</li>
<li>而下一次循环的 next = e.next 导致了 next 指向了 key(3)</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092343072-1415757438.png" alt=""></p>
<p>3）一切安好。</p>
<p>线程一接着工作。把 key(7) 摘下来，放到 newTable[i] 的第一个，然后把 e 和 next 往下移。</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092412353-1913638098.png" alt=""></p>
<p>4）环形链接出现。</p>
<p>e.next = newTable[i] 导致  key(3).next 指向了 key(7)</p>
<p>注意：此时的 key(7).next 已经指向了 key(3)， 环形链表就这样出现了。</p>
<p> <img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092444871-1558486337.png" alt=""></p>
<p> 于是，当我们的线程一调用到，HashTable.get(11) 时，悲剧就出现了——Infinite Loop。</p>
<p>因为 HashMap 本来就不支持并发。要并发就用 ConcurrentHashmap</p>
<p><strong>HashMap 的 get() 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F;直接调用了getNode()</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">     &#x2F;&#x2F;先判断数组是否为空，长度是否大于0，那个node节点是否存在</span><br><span class="line">     if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F;如果找到，直接返回</span><br><span class="line">          if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">              ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">              return first;</span><br><span class="line">         if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">             &#x2F;&#x2F;如果是红黑树，去红黑树找</span><br><span class="line">             if (first instanceof TreeNode)</span><br><span class="line">                 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">             &#x2F;&#x2F;链表找</span><br><span class="line">             do &#123;</span><br><span class="line">                 if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                     ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                     return e;</span><br><span class="line">             &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>这里关于<code>first = tab[(n - 1) &amp; hash]</code></p>
<p>这里通过<code>(n - 1)&amp; hash</code>即可算出桶的在桶数组中的位置，可能有的朋友不太明白这里为什么这么做，这里简单解释一下。HashMap 中桶数组的大小 length 总是 2 的幂，此时，<code>(n - 1) &amp; hash</code> 等价于对 length 取余。但取余的计算效率没有位运算高，所以<code>(n - 1) &amp; hash</code>也是一个小的优化。举个例子说明一下吧，假设 hash = 185，n = 16。计算过程示意图如下</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906095115131-234992109.png" alt=""></p>
<p> 在上面源码中，除了查找相关逻辑，还有一个计算 hash 的方法。这个方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算键的 hash 值</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看这个方法的逻辑好像是通过位运算重新计算 hash，那么这里为什么要这样做呢？为什么不直接用键的 hashCode 方法产生的 hash 呢？大家先可以思考一下，我把答案写在下面。</p>
<p>这样做有两个好处，我来简单解释一下。我们再看一下上面求余的计算图，图中的 hash 是由键的 hashCode 产生。计算余数时，由于 n 比较小，hash 只有低 4 位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以上图中的 hash 高 4 位数据与低 4 位数据进行异或运算，即 <code>hash ^ (hash &gt;&gt;&gt; 4)</code>。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。此时的计算过程如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906095432574-555473243.png" alt=""></p>
<p>在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前 16 位为高位，后 16 位为低位，所以要右移 16 位。</p>
<p>上面所说的是重新计算 hash 的一个好处，除此之外，重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因了。</p>
<p>由于个人能力问题, 先学习这些, 数据结构这个大山, 我一定要刨平它。</p>
<p>基于 jdk1.7 版本的 HashMap</p>
<p><a href="https://www.jianshu.com/p/dde9b12343c1" target="_blank" rel="noopener">https://www.jianshu.com/p/dde9b12343c1</a></p>
<p>参考博客:</p>
<p><a href="https://www.cnblogs.com/wenbochang/archive/2018/02/22/8458756.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenbochang/archive/2018/02/22/8458756.html</a></p>
<p><a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722</a></p>
<p><a href="https://blog.csdn.net/pange1991/article/details/82377980" target="_blank" rel="noopener">https://blog.csdn.net/pange1991/article/details/82377980</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://topone233.github.io/2020/07/10/HashMap%20%E5%89%96%E6%9E%90%20(%E5%9F%BA%E4%BA%8E%20jdk1.8)/" data-id="ckcg06n1q0000ac21c0ta3de8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HashMap 面试必问的数据结构相关知识总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/HashMap%20%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-07-10T09:07:59.400Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/HashMap%20%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">HashMap 面试必问的数据结构相关知识总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文地址 <a href="https://www.cnblogs.com/Young111/p/11519952.html" target="_blank" rel="noopener">www.cnblogs.com</a></p>
</blockquote>
<p><strong>1：HashMap 的数据结构？</strong></p>
<p>​        哈希表结构（链表散列：数组 + 链表）实现，结合数组和链表的优点。当链表长度超过 8 时，链表转换为红黑树。<br>transient Node&lt;K,V&gt;[] table;</p>
<p><strong>2：HashMap 的工作原理？</strong></p>
<p>　　HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry&lt;K,V&gt; 接口）实现，HashMap 通过 put &amp; get 方法存储和获取。</p>
<p>存储对象时，将 K/V 键值传给 put() 方法：</p>
<p>​    ①、调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；</p>
<p>​    ②、调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容 resize 为 2n）；  </p>
<p>​    ③、如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；<br> 　　   如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；<br>　　    如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中。</p>
<p>（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）<br>（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）</p>
<p>　　获取对象时，将 K 传给 get() 方法：<br>　　①、调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；<br>　　②、顺序遍历链表，equals() 方法查找相同 Node 链表中 K 值对应的 V 值。</p>
<p>hashCode 是定位的，找到存储位置；equals 是定性的，比较两者是否相等。</p>
<p><strong>3. 当两个对象的 hashCode 相同会发生什么？</strong></p>
<p>　　因为 hashCode 相同，不一定就是相等的（equals 方法比较），如果两个对象所在数组的下标相同，”碰撞” 就此发生。又因为 HashMap 使用链表存储对象，这个 Node 会存储到链表中。</p>
<p><strong>4. 你知道 hash 的实现吗？为什么要这样实现？</strong></p>
<p>　　JDK 1.8 中，是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。</p>
<p><strong>5. 为什么要用异或运算符？</strong>  </p>
<p>​        保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。</p>
<p><strong>6. HashMap 的 table 的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？</strong></p>
<p>​        ①、table 数组大小是由capacity这个参数确定的，默认是 16，也可以构造时传入，最大限制是 1&lt;&lt;30；  </p>
<p>​        ②、loadFactor 是装载因子，主要目的是用来确认 table 数组是否需要动态扩展，默认值是 0.75，比如 table 数组大小为 16，装载               因子为 0.75 时，threshold 就是 12，当 table 的实际大小超过 12 时，table 就需要动态扩容；  </p>
<p>​        ③、扩容时，调用 resize() 方法，将 table 长度变为原来的两倍（注意是 table 长度，而不是 threshold）  </p>
<p>​        ④、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。</p>
<p><strong>7.HashMap 中 put 方法的过程？</strong></p>
<ul>
<li>答：“调用哈希函数获取 Key 对应的 hash 值，再计算其数组下标；</li>
<li>如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；</li>
<li>如果链表长度超过阀值 (TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于 6，就把红黑树转回链表;</li>
<li>如果结点的 key 已经存在，则替换其 value 即可；</li>
<li>如果集合中的键值对大于 12，调用 resize 方法进行数组扩容。”</li>
</ul>
<p><strong>8. 数组扩容的过程？</strong></p>
<p>　　创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标 + 旧数组的大小。</p>
<p><strong>9. 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</strong></p>
<p>​        之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持 “平衡” 是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于 8 的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p>
<p><strong>10. 说说你对红黑树的见解？</strong></p>
<ul>
<li>1、每个节点非红即黑</li>
<li>2、根节点总是黑色的</li>
<li>3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li>
<li>4、每个叶子节点都是黑色的空节点（NIL 节点）</li>
<li>5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li>
</ul>
<p><strong>11.jdk8 中对 HashMap 做了哪些改变？</strong></p>
<ul>
<li>在 java 1.8 中，如果链表的长度超过了 8，那么链表将转换为红黑树。（桶的数量必须大于 64，小于 64 的时候只会扩容）</li>
<li>发生 hash 碰撞时，java 1.7 会在链表的头部插入，而 java 1.8 会在链表的尾部插入</li>
<li>在 java 1.8 中，Entry 被 Node 替代 (换了一个马甲)。</li>
</ul>
<p><strong>12.HashMap，LinkedHashMap，TreeMap 有什么区别？</strong><br>　　HashMap 参考其他问题：<br>　　LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；<br>　　TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）</p>
<p><strong>13.HashMap &amp; TreeMap &amp; LinkedHashMap 使用场景？</strong><br>　　一般情况下，使用最多的是 HashMap。<br>　　HashMap：在 Map 中插入、删除和定位元素时；<br>　　TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；<br>　　LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。</p>
<p><strong>14.HashMap 和 HashTable 有什么区别？</strong><br>　　①、HashMap 是线程不安全的，HashTable 是线程安全的；<br>　　②、由于线程安全，所以 HashTable 的效率比不上 HashMap；<br>　　③、HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null，而 HashTable 不允许；<br>　　④、HashMap 默认初始化数组的大小为 16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍 + 1；<br>　　⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</p>
<p><strong>15.Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？</strong><br>　　ConcurrentHashMap 类（是 Java 并发包 java.util.concurrent 中提供的一个线程安全且高效的 HashMap 实现）。<br>　　HashTable 是使用 synchronize 关键字加锁的原理（就是对对象加锁）；<br>　　而针对 ConcurrentHashMap，在 JDK 1.7 中采用 分段锁的方式；JDK 1.8 中直接采用了 CAS（无锁算法）+ synchronized。</p>
<p><strong>16.HashMap &amp; ConcurrentHashMap 的区别？</strong></p>
<p>　　除了加锁，原理上无太大区别。另外，HashMap 的键值对允许有 null，但是 ConCurrentHashMap 都不允许。</p>
<p><strong>17. 为什么 ConcurrentHashMap 比 HashTable 效率要高？</strong></p>
<p>　　HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；</p>
<p>　　ConcurrentHashMap </p>
<ul>
<li>JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。</li>
<li>JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结点）（实现 Map.Entry&lt;K,V&gt;）。锁粒度降低了。</li>
</ul>
<p><strong>18. 针对 ConcurrentHashMap 锁机制具体分析（JDK 1.7 VS JDK 1.8）？</strong></p>
<p>　　JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组 + 链表的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。<br>　　　　①、Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；<br>　　　　②、HashEntry 用来封装映射表的键 - 值对；<br>　　　　③、每个桶是由若干个 HashEntry 对象链接起来的链表</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190914193055199-705993926.png" alt=""></p>
<p>　　JDK 1.8 中，采用 Node + CAS + Synchronized 来保证并发安全。取消类 Segment，直接用 table 数组存储键值对；当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD 时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7779232-1e8ed39548081a1f.png" alt=""></p>
<p><strong>19.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？</strong><br>        ①、粒度降低了；<br>        ②、JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized 优化空间更大，更加自然。<br>        ③、在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。</p>
<p><strong>20.ConcurrentHashMap 简单介绍？</strong></p>
<p>①、重要的常量：<br>　　private transient volatile int sizeCtl;<br>　　当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；<br>　　当为 0 时，表示 table 还没有初始化；<br>　　当为其他正数时，表示初始化或者下一次进行扩容的大小。</p>
<p>②、数据结构：<br>　　Node 是存储结构的基本单元，继承 HashMap 中的 Entry，用于存储数据；<br>　　TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；<br>　　TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。</p>
<p>③、存储对象时（put() 方法）：<br>　　1. 如果没有初始化，就调用 initTable() 方法来进行初始化；<br>　　2. 如果没有 hash 冲突就直接 CAS 无锁插入；<br>　　3. 如果需要扩容，就先进行扩容；<br>　　4. 如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；<br>　　5. 如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环<br>　　6. 如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。</p>
<p>④、扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。<br>　　helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。</p>
<p>⑤、获取对象时（get() 方法）：<br>　　1. 计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；<br>　　2. 如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find() 方法，查找该结点，匹配就返回；<br>　　3. 以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。</p>
<p><strong>21.ConcurrentHashMap 的并发度是什么？</strong></p>
<p>　　程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小 2 幂指数作为实际并发度（假如用户设置并发度为 17，实际并发度则为 32）</p>
<p>有时间会对 HashTable，ConcurrentHashmap 解析。</p>
<p>参考博客：<br><a href="https://www.cnblogs.com/heqiyoujing/p/11143298.html" target="_blank" rel="noopener">https://www.cnblogs.com/heqiyoujing/p/11143298.html</a></p>
<p><a href="https://www.jianshu.com/p/75adf47958a7" target="_blank" rel="noopener">https://www.jianshu.com/p/75adf47958a7</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://topone233.github.io/2020/07/10/HashMap%20%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" data-id="ckcg06n1w0001ac217hb82tit" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浅谈HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/%E6%B5%85%E8%B0%88HashMap/" class="article-date">
  <time datetime="2020-07-10T09:07:59.392Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/%E6%B5%85%E8%B0%88HashMap/">浅谈HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><ul>
<li>什么是哈希表</li>
<li>HashMap的实现原理</li>
<li>为何HashMap的数组长度一定是2的次幂</li>
<li>重写equals方法需同时重写hashCode方法</li>
<li>JDK1.8中HashMap的性能优化  </li>
</ul>
<p>参考自：<a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464" target="_blank" rel="noopener">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p>
<h4 id="1-什么是哈希表"><a href="#1-什么是哈希表" class="headerlink" title="1.什么是哈希表"></a>1.什么是哈希表</h4><p>讨论哈希表之前，先大概了解下其他数据结构</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>采用一段连续的存储单元来存储数据。</p>
<p>通过指定下标查找，时间复杂度为O(1)；</p>
<p>通过给定值查找，需要遍历数组，逐一对比给定关键字和数组元素，时间复杂度O(n)。</p>
<p>对于有序数组，则可采用二分查找、插值查找、斐波那契查找等方式，可将复杂度提高到O(logn)；一般的插入删除操作，涉及到数组元素的移动，评价复杂度也为O(n)。</p>
<h5 id="线性链表"><a href="#线性链表" class="headerlink" title="线性链表"></a>线性链表</h5><p>对于链表的新增、删除等操作，在找到指定操作位置后，仅需处理结点间的引用即可，时间复杂度为O(1),而查找操作需要遍历链表逐一进行对比，复杂度为O(n)。</p>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>对一棵相对平衡的有序二叉树，CRUD，平均复杂度均为O(logn)。</p>
<h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>哈希表(hash table)进行CRUD，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。</p>
<p>数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构。栈、队列、树、图等都是从逻辑结构去抽象，映射到内存中，也是这两种物理组织形式。</p>
<p>哈希表主干是数组。<br>如果要新增或查找某个元素，把元素的关键字，通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可以完成。这个函数可以简单描述为：存储位置=f(关键字)。函数f一般成为哈希函数，直接影响到哈希表的优劣。</p>
<h5 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h5><p>如果两个不同的元素，通过哈希函数得出的实际存储地址相同；或者元素哈希运算得到一个存储地址，进行插入的时候发现已经被其他元素占用了，这就是所谓的哈希冲突，也叫哈希碰撞。 </p>
<p>好的哈希函数会尽可能使计算简单和散列地址分布均匀。但是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。  </p>
<p>哈希冲突的解决方案有多种：开放定址法(发生冲突，继续寻找下一块未被占用的存储地址)、再散列函数法、链地址法。HashMap采用的即是链地址法，也就是数组+链表的方式。 </p>
<h4 id="2-HashMap的实现原理"><a href="#2-HashMap的实现原理" class="headerlink" title="2.HashMap的实现原理"></a>2.HashMap的实现原理</h4><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓的Map就是保存了两个对象之间的映射关系的一种集合）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主干是一个Entry数组，初始值为空数组，长度一定是2的次幂</span><br><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPty_TABLE;</span><br></pre></td></tr></table></figure>
<p>Entry是HashMap中的一个静态内部类。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    &#x2F;&#x2F;存储执向下一个Entry的引用，单链表结构</span><br><span class="line">    Entry&lt;K,V&gt; next; </span><br><span class="line">    &#x2F;&#x2F;对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span><br><span class="line">    int hash; </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;creats new entry</span><br><span class="line">    Entry(int h, k K, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value &#x3D; v;</span><br><span class="line">        next &#x3D; n;</span><br><span class="line">        key &#x3D; k;</span><br><span class="line">        hash &#x3D; h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h6><p>HashMap由数组+链表组成，Entry数组是HashMap的主体，链表用于解决哈希冲突。如果定位到的数组位置不含链表(当前entry的next指向null)，那么CRUD很快，O(1)，仅需一次寻址即可；如果定位到的数组包含链表，添加操作，复杂度O(n)，先遍历链表，存在即覆盖，否则新增；查找操作，仍需遍历链表，然后通过key对象的equals方法逐一对比查找。所以，HashMap中的链表出现越少，性能越好。 </p>
<p>HashMap的4个构造器size、threshold、loadFactor、modCount</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实际存储key-value键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;阈值，当table &#x3D;&#x3D; &#123;&#125;时，该值为初始容量(默认16)</span><br><span class="line">&#x2F;&#x2F;当table被填充了，也就是为table分配内存空间后，threshold一般为capacity*loadFactory</span><br><span class="line">&#x2F;&#x2F;HashMap在进行扩容时需要参考threshold</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负载因子，代表了table的填充度，默认是0.75</span><br><span class="line">&#x2F;&#x2F;负载因子存在的原因，还是为了减缓哈希冲突</span><br><span class="line">&#x2F;&#x2F;如果初始桶为16，等到满16个才扩容，某些桶可能就有不止一个元素了</span><br><span class="line">&#x2F;&#x2F;所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32</span><br><span class="line">final float loadFactor;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;HashMap被改变的次数</span><br><span class="line">&#x2F;&#x2F;由于HashMap非线程安全，在对HashMap进行迭代时，如果其他线程的参与导致HashMap的结构发生了变化(put、remove等操作)，需要抛出异常ConcurrentModificationException</span><br><span class="line">transient int modeCount;</span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">　　　　&#x2F;&#x2F;此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY &#x3D; 1&lt;&lt;30(230)</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        threshold &#x3D; initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        &#x2F;&#x2F;init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组  </p>
<p>put操作的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，</span><br><span class="line">        &#x2F;&#x2F;此时threshold为initialCapacity 默认是1&lt;&lt;4(24&#x3D;16)</span><br><span class="line">        if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">       &#x2F;&#x2F;如果key为null，存储位置为table[0]或table[0]的冲突链上</span><br><span class="line">        if (key &#x3D;&#x3D; null)</span><br><span class="line">            return putForNullKey(value);</span><br><span class="line">        int hash &#x3D; hash(key);&#x2F;&#x2F;对key的hashcode进一步计算，确保散列均匀</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);&#x2F;&#x2F;获取在table中的实际位置</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;&#x2F;&#x2F;保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span><br><span class="line">        addEntry(hash, key, value, i);&#x2F;&#x2F;新增一个entry</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">        &#x2F;&#x2F;capacity一定是2的次幂</span><br><span class="line">        int capacity &#x3D; roundUpToPowerOf2(toSize);</span><br><span class="line">        &#x2F;&#x2F;此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，</span><br><span class="line">        &#x2F;&#x2F;capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 </span><br><span class="line">        threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">        table &#x3D; new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">       &#x2F;&#x2F; assert number &gt;&#x3D; 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">       return number &gt;&#x3D; MAXIMUM_CAPACITY</span><br><span class="line">               ? MAXIMUM_CAPACITY</span><br><span class="line">               : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>hash函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这是一个神奇的函数，用了很多的异或，移位等运算</span><br><span class="line">&#x2F;&#x2F;对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">        int h &#x3D; hashSeed;</span><br><span class="line">        if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^&#x3D; k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;返回数组下标</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为index=2。位运算对计算机来说，性能更高一些（HashMap中有大量位运算）  </p>
<p>所以最终存储位置的确定流程是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    hashCode()              hash()      indexFor()</span><br><span class="line">key ----------&gt; hashcode ----------&gt; h ------------&gt;  存储下标</span><br><span class="line">                                        h&amp;(length-1)</span><br></pre></td></tr></table></figure>


<p>再来看看addEntry的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;</span><br><span class="line">            &#x2F;&#x2F;当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">            hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作</p>
<h5 id="3-为何HashMap的数组长度一定是2的次幂"><a href="#3-为何HashMap的数组长度一定是2的次幂" class="headerlink" title="3.为何HashMap的数组长度一定是2的次幂"></a>3.为何HashMap的数组长度一定是2的次幂</h5><p>我们来继续看上面提到的resize方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable &#x3D; table;</span><br><span class="line">        int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">        if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table &#x3D; newTable;</span><br><span class="line">        threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity &#x3D; newTable.length;</span><br><span class="line">　　　　　&#x2F;&#x2F;for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null !&#x3D; e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">                &#x2F;&#x2F;将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span><br><span class="line">                e.next &#x3D; newTable[i];</span><br><span class="line">                newTable[i] &#x3D; e;</span><br><span class="line">                e &#x3D; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>
<p>HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>
<p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀</p>
<p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>
<p>如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>
<p>get方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">　　　　 &#x2F;&#x2F;如果key为null,则直接去table[0]处去检索即可。</span><br><span class="line">       if (key &#x3D;&#x3D; null)</span><br><span class="line">           return getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry &#x3D; getEntry(key);</span><br><span class="line">       return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。</p>
<p>我们再看一下getEntry方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">            </span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;通过key的hashcode值计算hash值</span><br><span class="line">        int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">        &#x2F;&#x2F;indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">             e !&#x3D; null;</span><br><span class="line">             e &#x3D; e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp; </span><br><span class="line">                ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>
<h5 id="4-重写equals方法需同时重写hashCode方法"><a href="#4-重写equals方法需同时重写hashCode方法" class="headerlink" title="4.重写equals方法需同时重写hashCode方法"></a>4.重写equals方法需同时重写hashCode方法</h5><p>先来看下如果重写equals而不重写hashcode会发生什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    private static class Person&#123;</span><br><span class="line">        int idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(int idCard, String name) &#123;</span><br><span class="line">            this.idCard &#x3D; idCard;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            if (this &#x3D;&#x3D; o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (o &#x3D;&#x3D; null || getClass() !&#x3D; o.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            Person person &#x3D; (Person) o;</span><br><span class="line">            &#x2F;&#x2F;两个对象是否等值，通过idCard来确定</span><br><span class="line">            return this.idCard &#x3D;&#x3D; person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map &#x3D; new HashMap&lt;Person, String&gt;();</span><br><span class="line">        Person person &#x3D; new Person(1234,&quot;乔峰&quot;);</span><br><span class="line">        &#x2F;&#x2F;put到hashmap中去</span><br><span class="line">        map.put(person,&quot;天龙八部&quot;);</span><br><span class="line">        &#x2F;&#x2F;get取出，从逻辑上讲应该能输出“天龙八部”</span><br><span class="line">        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际输出结果：null</span><br></pre></td></tr></table></figure>
<p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null(也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到)  </p>
<p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同(只不过会发生哈希冲突，应尽量避免)</p>
<h5 id="5-JDK1-8中HashMap的性能优化"><a href="#5-JDK1-8中HashMap的性能优化" class="headerlink" title="5.JDK1.8中HashMap的性能优化"></a>5.JDK1.8中HashMap的性能优化</h5><p>假如一个数组槽位上链上数据过多（即拉链过长的情况）导致性能下降该怎么办？  </p>
<p>JDK1.8在JDK1.7的基础上针对增加了红黑树来进行优化。即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://topone233.github.io/2020/07/10/%E6%B5%85%E8%B0%88HashMap/" data-id="ckcg06n1z0003ac21dooo5hje" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-二叉树的四种遍历方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2020-07-10T09:07:59.381Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/">二叉树的四种遍历方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文地址 <a href="https://www.cnblogs.com/du001011/p/11229170.html" target="_blank" rel="noopener">www.cnblogs.com</a></p>
</blockquote>
<p>二叉树的四种遍历方式：</p>
<ul>
<li>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问依次且仅被访问一次。<br>四种遍历方式分别为：先序遍历、中序遍历、后序遍历、层序遍历。</li>
<li><img src="https://img2018.cnblogs.com/blog/1542838/201907/1542838-20190722222821663-1408544995.png" alt=""></li>
</ul>
<p>树的相关术语：</p>
<p>节点的度：一个节点含有的子树的个数称为该节点的度；</p>
<p>叶节点：度为0的节点；</p>
<p>树的度：一棵树中，最大的节点的度；</p>
<p>森林：由m（m&gt;=0）棵互不相交的树的集合</p>
<p>树的符号表现法：（1（2（4（5，6）），3）</p>
<p>解读：祖先1的子节点2（子节点4（叶节点5，6）），3。同层子树间用逗号隔开。</p>
<p>遍历之前，我们首先介绍一下，如何创建一个二叉树，在这里我们用的是先建左树在建右树的方法，</p>
<p>首先要声明结点 TreeNode 类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    public int data;</span><br><span class="line">    public TreeNode leftChild;</span><br><span class="line">    public TreeNode rightChild;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int data)&#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来创建一颗二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 构建二叉树</span><br><span class="line">     * @param list   输入序列</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; list)&#123;</span><br><span class="line">        TreeNode node &#x3D; null;</span><br><span class="line">        if(list &#x3D;&#x3D; null || list.isEmpty())&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer data &#x3D; list.removeFirst();</span><br><span class="line">        if(data!&#x3D;null)&#123;</span><br><span class="line">            node &#x3D; new TreeNode(data);</span><br><span class="line">            node.leftChild &#x3D; createBinaryTree(list);</span><br><span class="line">            node.rightChild &#x3D; createBinaryTree(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们按照上面列的顺序一一讲解，</p>
<p>首先来看先序遍历，所谓的先序遍历就是先访问根节点，在访问左节点，最后访问右节点，</p>
<p><img src="https://img2018.cnblogs.com/blog/1542838/201907/1542838-20190722224917877-2136323533.png" alt=""></p>
<p>如上图所示，前序遍历结果为：ABDFECGHI</p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 二叉树前序遍历   根-&gt; 左-&gt; 右</span><br><span class="line">     * @param node    二叉树节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void preOrderTraveral(TreeNode node)&#123;</span><br><span class="line">        if(node &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.data+&quot; &quot;);</span><br><span class="line">        preOrderTraveral(node.leftChild);</span><br><span class="line">        preOrderTraveral(node.rightChild);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再者就是中序遍历，所谓的中序遍历就是先访问左节点，再访问根节点，最后访问右节点，</p>
<p><img src="https://img2018.cnblogs.com/blog/1542838/201907/1542838-20190722225534764-1572433775.png" alt=""></p>
<p>如上图所示，前序遍历结果为：DBEFAGHCI（G没有左子树，所以直接访问G，而不是访问H）</p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 二叉树中序遍历   左-&gt; 根-&gt; 右</span><br><span class="line">     * @param node   二叉树节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void inOrderTraveral(TreeNode node)&#123;</span><br><span class="line">        if(node &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderTraveral(node.leftChild);</span><br><span class="line">        System.out.print(node.data+&quot; &quot;);</span><br><span class="line">        inOrderTraveral(node.rightChild);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后就是中序遍历，所谓的中序遍历就是先访问左节点，再访问右节点，最后访问根节点。</p>
<p><img src="https://img2018.cnblogs.com/blog/1542838/201907/1542838-20190722225822242-120610112.png" alt=""></p>
<p>如上图所示，前序遍历结果为：DEFBHGICA</p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 二叉树后序遍历   左-&gt; 右-&gt; 根</span><br><span class="line">     * @param node    二叉树节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void postOrderTraveral(TreeNode node)&#123;</span><br><span class="line">        if(node &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrderTraveral(node.leftChild);</span><br><span class="line">        postOrderTraveral(node.rightChild);</span><br><span class="line">        System.out.print(node.data+&quot; &quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>讲完上面三种非递归的方法，下面再给大家讲讲非递归是如何实现前中后序遍历的</p>
<p>还是一样，先看非递归前序遍历</p>
<ol>
<li>首先申请一个新的栈，记为 stack；</li>
<li>声明一个结点 treeNode，让其指向 node 结点；</li>
<li>如果 treeNode 的不为空，将 treeNode 的值打印，并将 treeNode 入栈，然后让 treeNode 指向 treeNode 的右结点，</li>
<li>重复步骤 3，直到 treenode 为空；</li>
<li>然后出栈，让 treeNode 指向 treeNode 的右孩子</li>
<li>重复步骤 3，直到 stack 为空.</li>
</ol>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void preOrderTraveralWithStack(TreeNode node)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode treeNode &#x3D; node;</span><br><span class="line">        while(treeNode!&#x3D;null || !stack.isEmpty())&#123;</span><br><span class="line">            &#x2F;&#x2F;迭代访问节点的左孩子，并入栈</span><br><span class="line">            while(treeNode !&#x3D; null)&#123;</span><br><span class="line">                System.out.print(treeNode.data+&quot; &quot;);</span><br><span class="line">                stack.push(treeNode);</span><br><span class="line">                treeNode &#x3D; treeNode.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子</span><br><span class="line">            if(!stack.isEmpty())&#123;</span><br><span class="line">                treeNode &#x3D; stack.pop();</span><br><span class="line">                treeNode &#x3D; treeNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历非递归，在此不过多叙述具体步骤了，</p>
<p>具体过程：</p>
<ol>
<li>申请一个新栈，记为 stack，申请一个变量 cur，初始时令 treeNode 为头节点；</li>
<li>先把 treeNode 节点压入栈中，对以 treeNode 节点为头的整棵子树来说，依次把整棵树的左子树压入栈中，即不断令 treeNode=treeNode.leftChild，然后重复步骤 2；</li>
<li>不断重复步骤 2，直到发现 cur 为空，此时从 stack 中弹出一个节点记为 treeNode，打印 node 的值，并让 treeNode= treeNode.right，然后继续重复步骤 2；</li>
<li>当 stack 为空并且 cur 为空时结束。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void inOrderTraveralWithStack(TreeNode node)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode treeNode &#x3D; node;</span><br><span class="line">        while(treeNode!&#x3D;null || !stack.isEmpty())&#123;</span><br><span class="line">            while(treeNode !&#x3D; null)&#123;</span><br><span class="line">                stack.push(treeNode);</span><br><span class="line">                treeNode &#x3D; treeNode.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!stack.isEmpty())&#123;</span><br><span class="line">                treeNode &#x3D; stack.pop();</span><br><span class="line">                System.out.print(treeNode.data+&quot; &quot;);</span><br><span class="line">                treeNode &#x3D; treeNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历非递归实现，后序遍历这里较前两者实现复杂一点，我们需要一个标记为来记忆我们此时节点上一个节点，具体看代码注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void postOrderTraveralWithStack(TreeNode node)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode treeNode &#x3D; node;</span><br><span class="line">        TreeNode lastVisit &#x3D; null;   &#x2F;&#x2F;标记每次遍历最后一次访问的节点</span><br><span class="line">        while(treeNode!&#x3D;null || !stack.isEmpty())&#123;&#x2F;&#x2F;节点不为空，结点入栈，并且指向下一个左孩子</span><br><span class="line">            while(treeNode!&#x3D;null)&#123;</span><br><span class="line">                stack.push(treeNode);</span><br><span class="line">                treeNode &#x3D; treeNode.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;栈不为空</span><br><span class="line">            if(!stack.isEmpty())&#123;</span><br><span class="line">                &#x2F;&#x2F;出栈</span><br><span class="line">                treeNode &#x3D; stack.pop();</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 这块就是判断treeNode是否有右孩子，</span><br><span class="line">                 * 如果没有输出treeNode.data，让lastVisit指向treeNode，并让treeNode为空</span><br><span class="line">                 * 如果有右孩子，将当前节点继续入栈，treeNode指向它的右孩子,继续重复循环</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                if(treeNode.rightChild &#x3D;&#x3D; null || treeNode.rightChild &#x3D;&#x3D; lastVisit) &#123;</span><br><span class="line">                    System.out.print(treeNode.data + &quot; &quot;);</span><br><span class="line">                    lastVisit &#x3D; treeNode;</span><br><span class="line">                    treeNode  &#x3D; null;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    stack.push(treeNode);</span><br><span class="line">                    treeNode &#x3D; treeNode.rightChild;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后再介绍一下层序遍历</p>
<p>具体步骤如下：</p>
<ol>
<li>首先申请一个新的队列，记为 queue；</li>
<li>将头结点 head 压入 queue 中；</li>
<li>每次从 queue 中出队，记为 node，然后打印 node 值，如果 node 左孩子不为空，则将左孩子入队；如果 node 的右孩子不为空，则将右孩子入队；</li>
<li>重复步骤 3，直到 queue 为空。</li>
</ol>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void levelOrder(TreeNode root)&#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            root &#x3D; queue.pop();</span><br><span class="line">            System.out.print(root.data+&quot; &quot;);</span><br><span class="line">            if(root.leftChild!&#x3D;null) queue.add(root.leftChild);</span><br><span class="line">            if(root.rightChild!&#x3D;null) queue.add(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://topone233.github.io/2020/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/" data-id="ckcg06n1y0002ac211l1v9wy9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Hello World！（hexo配置记录）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/Hello%20World%EF%BC%81%EF%BC%88hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%EF%BC%89/" class="article-date">
  <time datetime="2020-07-10T09:07:59.370Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/Hello%20World%EF%BC%81%EF%BC%88hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%EF%BC%89/">Hello World！（hexo配置记录）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hello-World！（hexo配置记录）"><a href="#Hello-World！（hexo配置记录）" class="headerlink" title="Hello World！（hexo配置记录）"></a>Hello World！（hexo配置记录）</h1><p>以前在网上冲浪的时候只是不经意间发现许多让人眼前一亮的blog，由此萌生了create my blog的想法。</p>
<p>目前的blog搭建：</p>
<ul>
<li><p>CSDN/博客园平台  </p>
<p> 但我个人不是很喜欢这种，首先是太丑了（没错，就是你，CSDN）。  </p>
<p> 其次依托于平台，虽然只需要创作就行，但是感觉不是属于自己的，没有归属感</p>
</li>
<li><p>独立blog  </p>
<p> 租云服务器、买域名，还要管理维护，个人感觉略微有些费事，精力有限，还是简单点好</p>
</li>
<li><p>hexo  </p>
<p> 依托于Github，也是我目前选择的，配置相对简单快捷，主题丰富</p>
</li>
</ul>
<hr>
<h4 id="hexo配置步骤："><a href="#hexo配置步骤：" class="headerlink" title="hexo配置步骤："></a>hexo配置步骤：</h4><ul>
<li>安装Git</li>
<li>安装Node.js</li>
<li>安装hexo</li>
<li>生成ssh并添加到GitHub</li>
<li>部署项目</li>
<li>上传到GitHub</li>
<li>修改主题</li>
</ul>
<h5 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h5><p><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">下载地址</a>  </p>
<p>安装步骤：双击下载的exe文件，一路next就行</p>
<h5 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h5><p>Hexo是基于nodeJS环境的静态博客，npm是必备的  </p>
<p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>  </p>
<p>安装步骤：下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了</p>
<h5 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h5><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">下载地址</a>  </p>
<p>这里要说下，npm install出现一直停留在”fetchMetadata: sill resolveWithNewModule find-cache-dir@”解决方法，更换成淘宝的源（反正我是解决了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修改为淘宝源</span><br><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org </span><br><span class="line">&#x2F;&#x2F;配置后可通过下面方式来验证是否成功 </span><br><span class="line">npm config get registry </span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure>

<h5 id="4-生成ssh并添加到GitHub"><a href="#4-生成ssh并添加到GitHub" class="headerlink" title="4.生成ssh并添加到GitHub"></a>4.生成ssh并添加到GitHub</h5><p>SSH密钥可以防止其他人恶意部署文件到你的仓库  </p>
<p>首先要有GitHub账号，没有的自行注册  </p>
<p>创建一个仓库repository，名称为youname.github.io  </p>
<p>在gitbash中，配置GitHub账号信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;配置你的GitHub账号信息</span><br><span class="line">git config --global user.name &quot;YourName&quot;</span><br><span class="line">git config --global user.email &quot;YourEmail&quot;</span><br></pre></td></tr></table></figure>

<p>创建ssh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建ssh</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail@xx.com&quot;</span><br></pre></td></tr></table></figure>

<p>生成ssh，在gitbash中切换到文件目录cat读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;读取ssh文件内容</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>全部复制（包括开头的ssh-rsa，和尾部的email）<br>到GitHub 配置ssh，title随便起</p>
<h5 id="5-部署项目"><a href="#5-部署项目" class="headerlink" title="5.部署项目"></a>5.部署项目</h5><p>修改hexo的_config.yml文件配置信息（直接复制，只需要修改url即可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;YourgithubName&#x2F;YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>


<p>回到gitbash，进入hexo目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>这时，在<a href="http://localhost:4000就可以看到默认页面">http://localhost:4000就可以看到默认页面</a></p>
<h5 id="6-上传到GitHub"><a href="#6-上传到GitHub" class="headerlink" title="6.上传到GitHub"></a>6.上传到GitHub</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>将写好的文章部署到GitHub服务器，<br>执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>第一次deploy要输入GitHubusername和password<br>完成后<a href="https://yourgithubname.github.io，查看即可" target="_blank" rel="noopener">https://yourgithubname.github.io，查看即可</a></p>
<h5 id="7-修改主题"><a href="#7-修改主题" class="headerlink" title="7.修改主题"></a>7.修改主题</h5><p>hexo官网有推荐很多很多主题，自行选择</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://topone233.github.io/2020/07/10/Hello%20World%EF%BC%81%EF%BC%88hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%EF%BC%89/" data-id="ckcg06n1z0004ac21c6xy4l65" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/10/HashMap%20%E5%89%96%E6%9E%90%20(%E5%9F%BA%E4%BA%8E%20jdk1.8)/">HashMap 剖析 (基于 jdk1.8)</a>
          </li>
        
          <li>
            <a href="/2020/07/10/HashMap%20%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">HashMap 面试必问的数据结构相关知识总结</a>
          </li>
        
          <li>
            <a href="/2020/07/10/%E6%B5%85%E8%B0%88HashMap/">浅谈HashMap</a>
          </li>
        
          <li>
            <a href="/2020/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/">二叉树的四种遍历方式</a>
          </li>
        
          <li>
            <a href="/2020/07/10/Hello%20World%EF%BC%81%EF%BC%88hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%EF%BC%89/">Hello World！（hexo配置记录）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 QSX1C<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>HashMap 剖析 (基于 jdk1.8) | topone233</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"></head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">topone233</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">HashMap 剖析 (基于 jdk1.8)</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2020/07/10/HashMap%20%E5%89%96%E6%9E%90%20(%E5%9F%BA%E4%BA%8E%20jdk1.8)/">2020-07-10</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p>原文地址 <a href="https://www.cnblogs.com/Young111/p/11471049.html" target="_blank" rel="noopener">www.cnblogs.com</a></p>
<p>本文的源码是基于 JDK1.8 版本，在学习 HashMap 之前，先了解数组和链表的知识。</p>
<p><strong>数组：</strong><br>数组具有遍历快，增删慢的特点。数组在堆中是一块连续的存储空间，遍历时数组的首地址是知道的（首地址 = 首地址 + 元素字节数 * 下标），所以遍历快（数组遍历的时间复杂度为 O(1) ）；增删慢是因为，当在中间插入或删除元素时，会造成该元素后面所有元素地址的改变，所以增删慢（增删的时间复杂度为 O(n) ）。</p>
<p><strong>链表：</strong><br>链表具有增删快，遍历慢的特点。链表中各元素的内存空间是不连续的，一个节点至少包含节点数据与后继节点的引用，所以在插入删除时，只需修改该位置的前驱节点与后继节点即可，链表在插入删除时的时间复杂度为 O(1)。但是在遍历时，get(n) 元素时，需要从第一个开始，依次拿到后面元素的地址，进行遍历，直到遍历到第 n 个元素（时间复杂度为 O(n) ），所以效率极低。</p>
<p><strong>HashMap:</strong><br>Hash 表是一个数组 + 链表的结构，这种结构能够保证在遍历与增删的过程中，如果不产生 hash 碰撞，仅需一次定位就可完成，时间复杂度能保证在 O(1)。  在 jdk1.7 中，只是单纯的数组 + 链表的结构，但是如果散列表中的 hash 碰撞过多时，会造成效率的降低，所以在 JKD1.8 中对这种情况进行了控制，当一个 hash 值上的链表长度大于 8 时，该节点上的数据就不再以链表进行存储，而是转成了一个红黑树。</p>
<p>红黑树:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>hash 碰撞：</strong><br>hash 是指，两个元素通过 hash 函数计算出的值是一样的，是同一个存储地址。当后面的元素要插入到这个地址时，发现已经被占用了，这时候就产生了 hash 冲突</p>
<p><strong>hash 冲突的解决方法：</strong><br>开放定址法 (查询产生冲突的地址的下一个地址是否被占用，直到寻找到空的地址)，再散列法，链地址法等。hashmap 采用的就是链地址法，jdk1.7 中，当冲突时，在冲突的地址上生成一个链表，将冲突的元素的 key，通过 equals 进行比较，相同即覆盖，不同则添加到链表上，此时如果链表过长，效率就会大大降低，查找和添加操作的时间复杂度都为 O(n)；但是在 jdk1.8 中如果链表长度大于 8，链表就会转化为红黑树，下图就是 1.8 版本的（图片来源 <a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722</a>），时间复杂度也降为了 O(logn)，性能得到了很大的优化。</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906090342350-1437652164.png" alt=""></p>
<p><strong>下面通过源码分析一下，HashMap 的底层实现</strong></p>
<p>首先，hashMap 的主干是一个 Node 数组（jdk1.7 及之前为 Entry 数组）每一个 Node 包含一个 key 与 value 的键值对，与一个 next 指向下一个 node，hashMap 由多个 Node 对象组成。</p>
<p>Node 是 HhaspMap 中的一个静态内部类 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">         final int hash;</span><br><span class="line">         final K key;</span><br><span class="line">         V value;</span><br><span class="line">         Node&lt;K,V&gt; next;</span><br><span class="line"> </span><br><span class="line">         Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">             this.key &#x3D; key;</span><br><span class="line">             this.value &#x3D; value;</span><br><span class="line">             this.next &#x3D; next;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         public final K getKey()        &#123; return key; &#125;</span><br><span class="line">         public final V getValue()      &#123; return value; &#125;</span><br><span class="line">         public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;hashCode等其他代码</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


<p>再看下 hashMap 中几个重要的字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认初始容量为16，0000 0001 左移4位 0001 0000为16，主干数组的初始容量为16，而且这个数组</span><br><span class="line">&#x2F;&#x2F;必须是2的倍数(后面说为什么是2的倍数)</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;最大容量为int的最大值除2</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;默认加载因子为0.75</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;阈值，如果主干数组上的链表的长度大于8，链表转化为红黑树</span><br><span class="line"> static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;hash表扩容后，如果发现某一个红黑树的长度小于6，则会重新退化为链表</span><br><span class="line"> static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;当hashmap容量大于64时，链表才能转成红黑树</span><br><span class="line"> static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;临界值&#x3D;主干数组容量*负载因子</span><br><span class="line">int threshold；</span><br></pre></td></tr></table></figure>


<p><strong>HashMap 的构造方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;initialCapacity为初始容量，loadFactor为负载因子</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始容量小于0，抛出非法数据异常</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#x2F;&#x2F;初始容量最大为MAXIMUM_CAPACITY</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F;负载因子必须大于0，并且是合法数字</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        </span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        &#x2F;&#x2F;将初始容量转成2次幂</span><br><span class="line">        this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;tableSizeFor的作用就是，如果传入A，当A大于0，小于定义的最大容量时，</span><br><span class="line">    &#x2F;&#x2F;如果A是2次幂则返回A，否则将A转化为一个比A大且差距最小的2次幂。  </span><br><span class="line">    &#x2F;&#x2F;例如传入7返回8，传入8返回8，传入9返回16</span><br><span class="line">  static final int tableSizeFor(int cap) &#123;</span><br><span class="line">        int n &#x3D; cap - 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;调用上面的构造方法，自定义初始容量，负载因子为默认的0.75</span><br><span class="line"> public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;默认构造方法，负载因子为0.75，初始容量为DEFAULT_INITIAL_CAPACITY&#x3D;16，初始容量在第一次put时才会初始化</span><br><span class="line"> public HashMap() &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;传入一个MAP集合的构造方法</span><br><span class="line"> public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>HashMap 的 put() 方法</strong></p>
<p>put 方法的源码分析是本篇的一个重点，因为通过该方法我们可以窥探到 HashMap 在内部是如何进行数据存储的，所谓的数组 + 链表 + 红黑树的存储结构是如何形成的，又是在何种情况下将链表转换成红黑树来优化性能的。带着一系列的疑问，我们看这个 put 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是 put 方法调用了 putVal 方法，其中传入一个参数位 hash(key)，我们首先来看看 hash() 这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此处如果传入的 int 类型的值：①向一个 Object 类型赋值一个 int 的值时，会将 int 值自动封箱为 Integer。②integer 类型的 hashcode 都是他自身的值，即 h=key；h &gt;&gt;&gt; 16 为无符号右移 16 位，低位挤走，高位补 0；^ 为按位异或，即转成二进制后，相异为 1，相同为 0，由此可发现，当传入的值小于  2 的 16 次方 - 1 时，调用这个方法返回的值，都是自身的值。<br>然后再执行 putVal 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;onlyIfAbsent是true的话，不要改变现有的值</span><br><span class="line">&#x2F;&#x2F;evict为true的话，表处于创建模式 </span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">&#x2F;&#x2F;如果主干上的table为空，长度为0，调用resize方法，调整table的长度（resize方法在下图中）</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            &#x2F;* 这里调用resize，其实就是第一次put时，对数组进行初始化。</span><br><span class="line">               如果是默认构造方法会执行resize中的这几句话：</span><br><span class="line">               newCap &#x3D; DEFAULT_INITIAL_CAPACITY;  新的容量等于默认值16</span><br><span class="line">               newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);            </span><br><span class="line">               threshold &#x3D; newThr;   临界值等于16*0.75</span><br><span class="line">               Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap]; </span><br><span class="line">               table &#x3D; newTab; 将新的node数组赋值给table，然后return newTab</span><br><span class="line">                </span><br><span class="line">                如果是自定义的构造方法则会执行resize中的： </span><br><span class="line">                int oldThr &#x3D; threshold;   </span><br><span class="line">                newCap &#x3D; oldThr;   新的容量等于threshold，这里的threshold都是2的倍数，原因在    </span><br><span class="line">                于传入的数都经过tableSizeFor方法，返回了一个新值，上面解释过</span><br><span class="line">                float ft &#x3D; (float)newCap * loadFactor; </span><br><span class="line">                newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                (int)ft : Integer.MAX_VALUE); </span><br><span class="line">                 threshold &#x3D; newThr; 新的临界值等于 (int)(新的容量*负载因子)</span><br><span class="line">                Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">                table &#x3D; newTab; return newTab;</span><br><span class="line">            *&#x2F;</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;  &#x2F;&#x2F;将调用resize后构造的数组的长度赋值给n</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#x2F;&#x2F;将数组长度与计算得到的hash值比较</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);&#x2F;&#x2F;位置为空，将i位置上赋值一个node对象</span><br><span class="line">        else &#123;  &#x2F;&#x2F;位置不为空</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;  &#x2F;&#x2F; 如果这个位置的old节点与new节点的key完全相同</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) </span><br><span class="line">                e &#x3D; p;             &#x2F;&#x2F; 则e&#x3D;p</span><br><span class="line">            else if (p instanceof TreeNode) &#x2F;&#x2F; 如果p已经是树节点的一个实例，既这里已经是树了</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;  &#x2F;&#x2F;p与新节点既不完全相同，p也不是treenode的实例</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;  &#x2F;&#x2F;一个死循环</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;   &#x2F;&#x2F;e&#x3D;p.next,如果p的next指向为null</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);  &#x2F;&#x2F;指向一个新的节点</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; 如果链表长度大于等于8</span><br><span class="line">                            treeifyBin(tab, hash);  &#x2F;&#x2F;将链表转为红黑树</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">       if (e.hash &#x3D;&#x3D; hash &amp;&amp;  &#x2F;&#x2F;如果遍历过程中链表中的元素与新添加的元素完全相同，则跳出循环</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e; &#x2F;&#x2F;将p中的next赋值给p,即将链表中的下一个node赋值给p，</span><br><span class="line">                           &#x2F;&#x2F;继续循环遍历链表中的元素</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F;这个判断中代码作用为：如果添加的元素产生了hash冲突，那么调用                </span><br><span class="line">                             &#x2F;&#x2F;put方法时，会将他在链表中他的上一个元素的值返回</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)  &#x2F;&#x2F;判断条件成立的话，将oldvalue替换        </span><br><span class="line">                &#x2F;&#x2F;为newvalue，返回oldvalue；不成立则不替换，然后返回oldvalue</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                afterNodeAccess(e);  &#x2F;&#x2F;这个方法在后面说</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;  &#x2F;&#x2F;记录修改次数</span><br><span class="line">        if (++size &gt; threshold)   &#x2F;&#x2F;如果元素数量大于临界值，则进行扩容</span><br><span class="line">            resize();   &#x2F;&#x2F;下面说</span><br><span class="line">        afterNodeInsertion(evict);  </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>在 Java 8 中，如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8)，就使用红黑树来替换链表，从而提高速度。上诉代码这个替换的方法叫 treeifyBin() 即树形化。</p>
<p>看一下 treeifyBin() 的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将桶内所有的 链表节点 替换成 红黑树节点</span><br><span class="line"> final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">   int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F;如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建&#x2F;扩容</span><br><span class="line">   if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果哈希表中的元素个数超过了 树形化阈值，进行树形化</span><br><span class="line">        &#x2F;&#x2F; e 是哈希表中指定位置桶里的链表节点，从第一个开始</span><br><span class="line">        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null; &#x2F;&#x2F;红黑树的头、尾节点</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;新建一个树形节点，内容和当前链表节点 e 一致</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">            if (tl &#x3D;&#x3D; null) &#x2F;&#x2F;确定树头节点</span><br><span class="line">                hd &#x3D; p;</span><br><span class="line">           else &#123;</span><br><span class="line">               p.prev &#x3D; tl;</span><br><span class="line">                tl.next &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl &#x3D; p;</span><br><span class="line">        &#125; while ((e &#x3D; e.next) !&#x3D; null); </span><br><span class="line">        &#x2F;&#x2F;让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span><br><span class="line">        if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>注释已经很详细了，咱们说一下这个初始化的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果 table 还未被初始化，那么初始化它</span><br><span class="line">if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">n &#x3D; (tab &#x3D; resize()).length;</span><br></pre></td></tr></table></figure>

<p>resize() 扩容机制，单元素如何散列到新的数组中，链表中的元素如何散列到新的数组中，红黑树中的元素如何散列到新的数组中？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;上图中说了默认构造方法与自定义构造方法第一次执行resize的过程，这里再说一下扩容的过程   </span><br><span class="line"> final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;  &#x2F;&#x2F;扩容肯定执行这个分支</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;   &#x2F;&#x2F;当容量超过最大值时，临界值设置为int最大值</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY) &#x2F;&#x2F;扩容容量为2倍，临界值为2倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; 不执行</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        else &#123;                &#x2F;&#x2F; 不执行</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 不执行</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold &#x3D; newThr;    &#x2F;&#x2F;将新的临界值赋值赋值给threshold</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;   &#x2F;&#x2F;新的数组赋值给table</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;扩容后，重新计算元素新的位置</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;   &#x2F;&#x2F;原数组</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;   &#x2F;&#x2F;通过原容量遍历原数组</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;   &#x2F;&#x2F;判断node是否为空，将j位置上的节点</span><br><span class="line">                &#x2F;&#x2F;保存到e,然后将oldTab置为空，这里为什么要把他置为空呢，置为空有什么好处吗？？</span><br><span class="line">                &#x2F;&#x2F;难道是吧oldTab变为一个空数组，便于垃圾回收？？ 这里不是很清楚</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)          &#x2F;&#x2F;判断node上是否有链表</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e; &#x2F;&#x2F;无链表，确定元素存放位置，</span><br><span class="line">                    &#x2F;&#x2F;扩容前的元素地址为 (oldCap - 1) &amp; e.hash ,所以这里的新的地址只有两种可能，一是地址不变，</span><br><span class="line">                    &#x2F;&#x2F;二是变为 老位置+oldCap</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line"> </span><br><span class="line">                      </span><br><span class="line">&#x2F;* 这里如果判断成立，那么该元素的地址在新的数组中就不会改变。因为oldCap的最高位的1，在e.hash对应的位上为0，所以扩容后得到的地址是一样的，位置不会改变 ，在后面的代码的执行中会放到loHead中去，最后赋值给newTab[j]；</span><br><span class="line">如果判断不成立，那么该元素的地址变为 原下标位置+oldCap，也就是lodCap最高位的1，在e.hash对应的位置上也为1，所以扩容后的地址改变了，在后面的代码中会放到hiHead中，最后赋值给newTab[j + oldCap]</span><br><span class="line">             举个栗子来说一下上面的两种情况：</span><br><span class="line">            设：oldCap&#x3D;16 二进制为：0001 0000</span><br><span class="line">                oldCap-1&#x3D;15 二进制为：0000 1111</span><br><span class="line">                e1.hash&#x3D;10 二进制为：0000 1010</span><br><span class="line">                e2.hash&#x3D;26 二进制为：0101 1010</span><br><span class="line">            e1在扩容前的位置为：e1.hash &amp; oldCap-1  结果为：0000 1010 </span><br><span class="line">            e2在扩容前的位置为：e2.hash &amp; oldCap-1  结果为：0000 1010 </span><br><span class="line">            结果相同，所以e1和e2在扩容前在同一个链表上，这是扩容之前的状态。</span><br><span class="line">            </span><br><span class="line">    现在扩容后，需要重新计算元素的位置，在扩容前的链表中计算地址的方式为e.hash &amp; oldCap-1</span><br><span class="line">    那么在扩容后应该也这么计算呀，扩容后的容量为oldCap*2&#x3D;32 0010 0000 newCap&#x3D;32，新的计算</span><br><span class="line">    方式应该为</span><br><span class="line">    e1.hash &amp; newCap-1 </span><br><span class="line">    即：0000 1010 &amp; 0001 1111 </span><br><span class="line">    结果为0000 1010与扩容前的位置完全一样。</span><br><span class="line">    e2.hash &amp; newCap-1 </span><br><span class="line">    即：0101 1010 &amp; 0001 1111 </span><br><span class="line">    结果为0001 1010,为扩容前位置+oldCap。</span><br><span class="line">    而这里却没有e.hash &amp; newCap-1 而是 e.hash &amp; oldCap，其实这两个是等效的，都是判断倒数第五位</span><br><span class="line">    是0，还是1。如果是0，则位置不变，是1则位置改变为扩容前位置+oldCap。</span><br><span class="line">            再来分析下loTail loHead这两个的执行过程（假设(e.hash &amp; oldCap) &#x3D;&#x3D; 0成立）：</span><br><span class="line">            第一次执行：</span><br><span class="line">            e指向oldTab[j]所指向的node对象，即e指向该位置上链表的第一个元素</span><br><span class="line">            loTail为空,所以loHead指向与e相同的node对象，然后loTail也指向了同一个node对象。</span><br><span class="line">            最后，在判断条件e指向next，就是指向oldTab链表中的第二个元素</span><br><span class="line">            第二次执行：</span><br><span class="line">            lotail不为null，所以lotail.next指向e，这里其实是lotail指向的node对象的next指向e，</span><br><span class="line">            也可以说是，loHead的next指向了e，就是指向了oldTab链表中第二个元素。此时loHead指向        </span><br><span class="line">            的node变成了一个长度为2的链表。然后lotail&#x3D;e也就是指向了链表中第二个元素的地址。</span><br><span class="line">            第三次执行：</span><br><span class="line">            与第二次执行类似，loHead上的链表长度变为3，又增加了一个node，loTail指向新增的node</span><br><span class="line">               ......</span><br><span class="line">            hiTail与hiHead的执行过程与以上相同，这里就不再做解释了。</span><br><span class="line">            由此可以看出，loHead是用来保存新链表上的头元素的，loTail是用来保存尾元素的，直到遍            </span><br><span class="line">            历完链表。   这是(e.hash &amp; oldCap) &#x3D;&#x3D; 0成立的时候。</span><br><span class="line">            (e.hash &amp; oldCap) &#x3D;&#x3D; 0不成立的情况也相同，其实就是把oldCap遍历成两个新的链表，</span><br><span class="line">            通过loHead和hiHead来保存链表的头结点，然后将两个头结点放到newTab[j]与 </span><br><span class="line">            newTab[j+oldCap]上面去      </span><br><span class="line">*&#x2F;</span><br><span class="line">                              do &#123;</span><br><span class="line">                                next &#x3D; e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;   &#x2F;&#x2F;尾节点的next设置为空</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;   &#x2F;&#x2F;尾节点的next设置为空</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>有关 JDK1.7 扩容出现的死循环的问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Transfers all entries from current table to newTable.</span><br><span class="line">*&#x2F;</span><br><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line"> Entry[] src &#x3D; table;</span><br><span class="line"> int newCapacity &#x3D; newTable.length;</span><br><span class="line"> for (int j &#x3D; 0; j &lt; src.length; j++) &#123;</span><br><span class="line">   Entry&lt;K,V&gt; e &#x3D; src[j];</span><br><span class="line">   if (e !&#x3D; null) &#123;</span><br><span class="line">       src[j] &#x3D; null;</span><br><span class="line">       do &#123;</span><br><span class="line">           &#x2F;&#x2F; B线程执行到这里之后就暂停了</span><br><span class="line">           Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">           int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">           e.next &#x3D; newTable[i];</span><br><span class="line">           newTable[i] &#x3D; e;</span><br><span class="line">           e &#x3D; next;</span><br><span class="line">       &#125; while (e !&#x3D; null);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>并发下的 Rehash</p>
<p>　　1）假设我们有两个线程。我用红色和浅蓝色标注了一下。我们再回头看一下我们的 transfer 代码中的这个细节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; next &#x3D; e.next; &#x2F;&#x2F; &lt;--假设线程一执行到这里就被调度挂起了</span><br><span class="line"></span><br><span class="line">    int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line"></span><br><span class="line">    e.next &#x3D; newTable[i];</span><br><span class="line"></span><br><span class="line">    newTable[i] &#x3D; e;</span><br><span class="line"></span><br><span class="line">    e &#x3D; next;</span><br><span class="line"></span><br><span class="line">&#125; while (e !&#x3D; null);</span><br></pre></td></tr></table></figure>


<p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092302379-1053929400.png" alt=""></p>
<p>注意，因为 Thread1 的 e 指向了 key(3)，而 next 指向了 key(7)，其在线程二 rehash 后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。</p>
<p>2）线程一被调度回来执行。</p>
<ul>
<li>先是执行 newTalbe[i] = e;</li>
<li>然后是 e = next，导致了 e 指向了 key(7)，</li>
<li>而下一次循环的 next = e.next 导致了 next 指向了 key(3)</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092343072-1415757438.png" alt=""></p>
<p>3）一切安好。</p>
<p>线程一接着工作。把 key(7) 摘下来，放到 newTable[i] 的第一个，然后把 e 和 next 往下移。</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092412353-1913638098.png" alt=""></p>
<p>4）环形链接出现。</p>
<p>e.next = newTable[i] 导致  key(3).next 指向了 key(7)</p>
<p>注意：此时的 key(7).next 已经指向了 key(3)， 环形链表就这样出现了。</p>
<p> <img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906092444871-1558486337.png" alt=""></p>
<p> 于是，当我们的线程一调用到，HashTable.get(11) 时，悲剧就出现了——Infinite Loop。</p>
<p>因为 HashMap 本来就不支持并发。要并发就用 ConcurrentHashmap</p>
<p><strong>HashMap 的 get() 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F;直接调用了getNode()</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">     &#x2F;&#x2F;先判断数组是否为空，长度是否大于0，那个node节点是否存在</span><br><span class="line">     if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F;如果找到，直接返回</span><br><span class="line">          if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">              ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">              return first;</span><br><span class="line">         if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">             &#x2F;&#x2F;如果是红黑树，去红黑树找</span><br><span class="line">             if (first instanceof TreeNode)</span><br><span class="line">                 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">             &#x2F;&#x2F;链表找</span><br><span class="line">             do &#123;</span><br><span class="line">                 if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                     ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                     return e;</span><br><span class="line">             &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>这里关于<code>first = tab[(n - 1) &amp; hash]</code></p>
<p>这里通过<code>(n - 1)&amp; hash</code>即可算出桶的在桶数组中的位置，可能有的朋友不太明白这里为什么这么做，这里简单解释一下。HashMap 中桶数组的大小 length 总是 2 的幂，此时，<code>(n - 1) &amp; hash</code> 等价于对 length 取余。但取余的计算效率没有位运算高，所以<code>(n - 1) &amp; hash</code>也是一个小的优化。举个例子说明一下吧，假设 hash = 185，n = 16。计算过程示意图如下</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906095115131-234992109.png" alt=""></p>
<p> 在上面源码中，除了查找相关逻辑，还有一个计算 hash 的方法。这个方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算键的 hash 值</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看这个方法的逻辑好像是通过位运算重新计算 hash，那么这里为什么要这样做呢？为什么不直接用键的 hashCode 方法产生的 hash 呢？大家先可以思考一下，我把答案写在下面。</p>
<p>这样做有两个好处，我来简单解释一下。我们再看一下上面求余的计算图，图中的 hash 是由键的 hashCode 产生。计算余数时，由于 n 比较小，hash 只有低 4 位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以上图中的 hash 高 4 位数据与低 4 位数据进行异或运算，即 <code>hash ^ (hash &gt;&gt;&gt; 4)</code>。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。此时的计算过程如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1408728/201909/1408728-20190906095432574-555473243.png" alt=""></p>
<p>在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前 16 位为高位，后 16 位为低位，所以要右移 16 位。</p>
<p>上面所说的是重新计算 hash 的一个好处，除此之外，重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因了。</p>
<p>由于个人能力问题, 先学习这些, 数据结构这个大山, 我一定要刨平它。</p>
<p>基于 jdk1.7 版本的 HashMap</p>
<p><a href="https://www.jianshu.com/p/dde9b12343c1" target="_blank" rel="noopener">https://www.jianshu.com/p/dde9b12343c1</a></p>
<p>参考博客:</p>
<p><a href="https://www.cnblogs.com/wenbochang/archive/2018/02/22/8458756.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenbochang/archive/2018/02/22/8458756.html</a></p>
<p><a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722</a></p>
<p><a href="https://blog.csdn.net/pange1991/article/details/82377980" target="_blank" rel="noopener">https://blog.csdn.net/pange1991/article/details/82377980</a></p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">QSX1C</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2020/07/10/HashMap%20%E5%89%96%E6%9E%90%20(%E5%9F%BA%E4%BA%8E%20jdk1.8)/">https://topone233.github.io/2020/07/10/HashMap 剖析 (基于 jdk1.8)/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://topone233.github.io">QSX1C的博客</a>！</span></div></blockquote></div></article><div class="p-info box"></div><aside id="toc"><div class="toc-title">目录</div><nav></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2020/07/10/Hello%20World%EF%BC%81%EF%BC%88hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%EF%BC%89/">&lt; Hello World！（hexo配置记录）</a><a class="next" href="/2020/07/10/HashMap%20%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">HashMap 面试必问的数据结构相关知识总结 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2020 <a href="/." rel="nofollow">topone233</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>
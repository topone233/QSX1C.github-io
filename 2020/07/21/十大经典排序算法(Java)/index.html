<!DOCTYPE html>
<html>
<head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />

  <!-- 页面元数据 -->
  
  <title>十大经典排序算法(Java) - QSX1C</title>
  
    <meta name="keywords" content="Java,数据结构,排序算法">
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css">

  
  

  

  
    <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  

  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  
  
  
  <!-- 脚本懒加载函数 -->
  <script>
  function loadScript(src, cb) {
    var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
    var script = document.createElement('script');
    script.setAttribute('type','text/javascript');
    if (cb) script.onload = cb;
    script.setAttribute('src', src);
    HEAD.appendChild(script);
  }
  //https://github.com/filamentgroup/loadCSS
  !function(c){"use strict";var e=function(e,t,n,r){var o,i=c.document,a=i.createElement("link");if(t)o=t;else{var d=(i.body||i.getElementsByTagName("head")[0]).childNodes;o=d[d.length-1]}var f=i.styleSheets;if(r)for(var l in r)r.hasOwnProperty(l)&&a.setAttribute(l,r[l]);a.rel="stylesheet",a.href=e,a.media="only x",function e(t){if(i.body)return t();setTimeout(function(){e(t)})}(function(){o.parentNode.insertBefore(a,t?o:o.nextSibling)});var s=function(e){for(var t=a.href,n=f.length;n--;)if(f[n].href===t)return e();setTimeout(function(){s(e)})};function u(){a.addEventListener&&a.removeEventListener("load",u),a.media=n||"all"}return a.addEventListener&&a.addEventListener("load",u),(a.onloadcssdefined=s)(u),a};"undefined"!=typeof exports?exports.loadCSS=e:c.loadCSS=e}("undefined"!=typeof global?global:this);
  </script>
  <script id="loadcss"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
  <header class="l_header auto shadow blur " style='opacity: 0' >
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div class="l_body">
    <div class="l_cover">
  
    
    
        <div class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">QSX1C</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              id="v4getting-started">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>博文</p>
            </a>
          
            <a href="/faqs/"
              
              
              id="faqs">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              id="examples">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              id="contributors">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f389.svg'><p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
            <a href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              id="https:githubcomvolantis-xhexo-theme-volantis">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg'><p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>
  
    <div class='safearea'>
      <div class='body-wrapper' id="pjax-container">
        
          <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">true</div> 
  <div id="pjax-pageTitle">十大经典排序算法(Java)</div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path"></div> 
  <div id="pjax-comment-placeholder"></div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover-wrapper')[0].style.display = "none"; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "half") { // 半屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'half'); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "full") { // 全屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'full'); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover-wrapper')[0].style.display = ""; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 
 

        
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        十大经典排序算法(Java)
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="">
    <p>QSX1C</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <a class='notlink'>
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Jul 21, 2020</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="十大经典排序算法(Java)" data-path="/2020/07/21/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(Java)/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <h3 id="1-排序算法说明"><a href="#1-排序算法说明" class="headerlink" title="1.排序算法说明"></a>1.排序算法说明</h3><h4 id="1-1-排序的定义"><a href="#1-1-排序的定义" class="headerlink" title="1.1 排序的定义"></a>1.1 排序的定义</h4><p>对一序列对象根据某个关键字进行排序。本文对十大排序算法进行解读。</p>
<h4 id="1-2-术语说明"><a href="#1-2-术语说明" class="headerlink" title="1.2 术语说明"></a>1.2 术语说明</h4><ul>
<li><strong>稳定</strong>：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li>
<li><strong>不稳定</strong>：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；</li>
<li><strong>内排序</strong>：所有排序操作都在内存中完成；</li>
<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li>
</ul>
<h4 id="1-3-算法总结"><a href="#1-3-算法总结" class="headerlink" title="1.3 算法总结"></a>1.3 算法总结</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015233043168-1867817869.png" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015233043168-1867817869.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p><strong>图片名词解释：</strong></p>
<ul>
<li>n: 数据规模</li>
<li>k: “桶” 的个数</li>
<li>In-place: 占用常数内存，不占用额外内存</li>
<li>Out-place: 占用额外内存</li>
</ul>
<h4 id="1-4-算法分类"><a href="#1-4-算法分类" class="headerlink" title="1.4 算法分类"></a>1.4 算法分类</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015233220637-1055088118.png" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015233220637-1055088118.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="1-5-比较和非比较的区别"><a href="#1-5-比较和非比较的区别" class="headerlink" title="1.5 比较和非比较的区别"></a>1.5 比较和非比较的区别</h4><p>常见的<strong>快速排序、归并排序、堆排序、冒泡排序</strong>等属于<strong>比较排序</strong>。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong><br>在<strong>冒泡排序</strong>之类的排序中，问题规模为 n，又因为需要比较 n 次，所以平均时间复杂度为 O(n²)。在<strong>归并排序、快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 logN 次，所以时间复杂度平均 <strong>O(nlogn)</strong>。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，<strong>比较排序适用于一切需要排序的情况。</strong></p>
<p><strong>计数排序、基数排序、桶排序</strong>则属于<strong>非比较排序</strong>。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组 arr，计算 arr[i] 之前有多少个元素，则唯一确定了 arr[i] 在排序后数组中的位置。<br>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 <strong>O(n)</strong>。<br><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p>
<h3 id="2-冒泡排序（Bubble-Sort）"><a href="#2-冒泡排序（Bubble-Sort）" class="headerlink" title="2.冒泡排序（Bubble Sort）"></a>2.冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。 </p>
<h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤 1~3，直到排序完成。</li>
</ul>
<h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a>2.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><pre><code>   　　/**
        * 冒泡排序
        * 依次比较相邻两个元素，并调整位置
        * 一趟排序后最大的数“冒泡”成功，到最右边
        * 重复“冒泡”
        * @param array
        * @return
        */
       public static int[] bubbleSort(int[] array) {
           if (array == null || array.length == 0) {
               return array;
           }
           // 外层：length-1次循环
           for (int i = 0; i &lt; array.length - 1; i++) {
               for (int j = 0; j &lt; array.length - 1 - i; j++) {
                   // 将较小的与大的交换位置
                   if (array[j + 1] &lt; array[j]) {
                       // 采用临时变量法交换
                       int temp = array[j + 1];
                       array[j + 1] = array[j];
                       array[j] = temp;
                   }
                }
             }
             return array;
         }</code></pre><h4 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h4><p>冒泡排序是稳定的排序算法，最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为<strong>O(n²)</strong>. 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为<strong>O(n)</strong>. 平均来讲, 时间复杂度为<strong>O(n²)</strong>. 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此<strong>空间复杂度为常量O(1)</strong>。</p>
<h3 id="3-选择排序（Selection-Sort）"><a href="#3-选择排序（Selection-Sort）" class="headerlink" title="3.选择排序（Selection Sort）"></a>3.选择排序（Selection Sort）</h3><p><strong>无论什么数据进去都是 O(n^2) 的时间复杂度</strong>，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<p>选择排序 (Selection-sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为 R[1..n]，有序区为空；</li>
<li>第 i 趟排序 (i=1,2,3…n-1) 开始时，当前有序区和无序区分别为 R[1..i-1]和 R(i..n）。该趟排序从当前无序区中 - 选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i]和 R[i+1..n)分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；</li>
<li>n-1 趟结束，数组有序化了。</li>
</ul>
<h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="">　　</p>
<h4 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h4><pre><code>　　/**
     * 选择排序
     * 遍历数组，在未排序的队列，找到最小或最大的数，放在左边形成有序队列
     * @param array
     * @return
     */
    public static int[] selectionSort(int[] array) {
        if (array.length == 0) {
            return array;
        }
        for (int i = 0; i &lt; array.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j &lt; array.length; j++) {
                // 找到最小的数
                if (array[j] &lt; array[minIndex]) 
                    // 将最小数的索引保存
                    minIndex = j; 
            }
            // 将i位置元素与找到的最小数，交换位置
            if (minIndex != i) {
                int temp = array[minIndex];
                array[minIndex] = array[i];
                array[i] = temp;
            }
        }
        return array;
    }</code></pre><h4 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h4><p><strong>最佳情况：O(n^2)  最差情况：O(n^2)  平均情况： O(n^2)</strong></p>
<h3 id="4-插入排序（Insertion-Sort）"><a href="#4-插入排序（Insertion-Sort）" class="headerlink" title="4.插入排序（Insertion Sort）"></a>4.插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ul>
<h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><p>提供两种写法，一种是移位法，一种是交换法。移位法是完全按照以上算法描述实，再插入过程中将有序序列中比待插入数字大的数据向后移动，由于移动时会覆盖待插入数据，所以需要额外的临时变量保存待插入数据，代码实现如下：</p>
<pre><code>　　/**
     * 插入排序-移位法
     * 每次在右侧未排序队列，选中一个元素，在左侧有序队列中，找适合自己的位置，并插入
     * @param array
     * @return
     */
    public static int[] insertionSort(int[] arr) {
        if (arr == null || arr.length == 0) {
            return arr;
        }
        for (int i = 0; i &lt; arr.length; i++) {
            int j = i - 1;
            // temp即被选中，进行操作的元素
            int temp = a[i]; 

            // 如果比待插入数据大，就后移
            while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) {
                // j位置元素大，后移，腾出位置
                arr[j + 1] = arr[j];
                // 一直向前，直到找到合适的位置
                j--;
            }
            // 找到比待插入数据小的位置，将待插入数据插入
            arr[j + 1] = temp;
        }
        return arr;
    }</code></pre><p>而交换法不需求额外的保存待插入数据，通过不停的向前交换带插入数据，类似冒泡法，直到找到比它小的值，也就是待插入数据找到了自己的位置:</p>
<pre><code>    public static void insertionSort(int[] arr) {
        if (arr == null || arr.length == 0) {
            return;
        }
        for (int i = 1; i &lt; arr.length; i++) {
            int j = i - 1;
             while (j &gt;= 0 &amp;&amp; arr[j] &gt; arr[i]) {
                // 只要大就交换操作
                arr[j + 1] = arr[j] + arr[j+1];      
                arr[j] = arr[j + 1] - arr[j];
                arr[j + 1] = arr[j + 1] - arr[j];
                System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));
             }
        }
    }</code></pre><h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 <strong>算法分析</strong></h4><p><strong>最佳情况： O(n)   最坏情况： O(n^2)   平均情况： O(n^2)    空间复杂度：O(1)</strong></p>
<h3 id="5-希尔排序（Shell-Sort）"><a href="#5-希尔排序（Shell-Sort）" class="headerlink" title="5.希尔排序（Shell Sort）"></a>5.希尔排序（Shell Sort）</h3><p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为<strong>缩小增量排序</strong>，同时该算法是冲破 O(n2）的第一批算法之一。它与插入排序的不同之处在于，<strong>它会优先比较距离较远的元素</strong>; 直接插入排序是稳定的；而希尔排序是不稳定的。希尔排序又叫缩小增量排序。</p>
<p>希尔排序是把记录按一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量 gap=length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示，<strong>{n/2,(n/2)/2…1}</strong>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h4 id="5-2-过程演示"><a href="#5-2-过程演示" class="headerlink" title="5.2 过程演示"></a>5.2 过程演示</h4><p><img src="https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180319094116040-1638766271.png" class="lazyload" data-srcset="https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180319094116040-1638766271.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><pre><code>　　/**
     * 希尔排序
     *
     * @param array
     * @return
     */
    public static int[] ShellSort(int[] array) {
        int len = array.length;
        // 初始增量gap
        int temp, gap = len / 2;
        while (gap &gt; 0) {
            for (int i = gap; i &lt; len; i++) {
                // temp放分组的第二个数，即中位数gap右边元素
                temp = array[i];
                // preIndex：分组第一个数 = i与中位数gap的差 = i自增的次数 = 左侧下标
                int preIndex = i - gap;
                //如果左侧元素大，交换位置
                while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) {
                    array[preIndex + gap] = array[preIndex];
                    preIndex -= gap;
                }
                array[preIndex + gap] = temp;
            }
            gap /= 2;
        }
        return array;
    }

    第二种写法：
    public static int[] ShellSort(int[] arr) {
        int gap = arr.length / 2;
        // 不断缩小gap，直到1为止
        for (;gap &gt; 0; gap = gap/2) {
            // j用来控制分组内多个元素时，比较的次数
            for (int j = 0; (j + gap) &lt; arr.length; j++) { 
                // k左侧元素，k+gap=右侧元素。依次调整每个分组
                for (int k = 0; (k + gap) &lt; arr.length; k++) { 
                    if (arr[k] &gt; arr[k+gap]) { 
                        // 交换操作
                        arr[k] = arr[k] + arr[k+gap];
                        arr[k+gap] = arr[k] - arr[k+gap];
                        arr[k] = arr[k] - arr[k+gap];
                        System.out.println(&quot;    Sorting:  &quot; + Arrays.toString(arr));
                    }</code></pre><h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>*<em>最佳情况： O(nlog n)  最坏情况： O(nlog n)  平均情况：O(nlog n)　*</em></p>
<h3 id="6-归并排序（Merge-Sort）"><a href="#6-归并排序（Merge-Sort）" class="headerlink" title="6.归并排序（Merge Sort）"></a>6.归并排序（Merge Sort）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。 </p>
<h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><ul>
<li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><pre><code>　　/**
     * 归并排序
     * 先分治，在合并
     * @param array
     * @return
     */
    public static int[] MergeSort(int[] array) {
        if (array.length &lt;= 1) {
            return array;
        }
        // &gt;&gt; 1 等价于 /2
        int mid = array.length &gt;&gt; 1;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
        return merge(MergeSort(left), MergeSort(right));
    }
    /**
     * 归并排序——将两段排序好的数组结合成一个排序数组
     *
     * @param left
     * @param right
     * @return
     */
    public static int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0;
        while (i &lt; left.length &amp;&amp; j &lt; right.length) {
            if (left[i] &lt;= right[j]) {
                result[k++] = left[i++];
            }else {
                result[k++] = right[j++];
            }
        }
        // left中的剩余元素移入结果数组
        while (i &lt; left.length) {
            result[k++] = left[i++]；
        }
        // right中的剩余元素移入结果数组
        while (j &lt; right.length) {
            result[k++] = right[j++];
        }
        return result;
    }</code></pre><h4 id="6-4-算法分析"><a href="#6-4-算法分析" class="headerlink" title="6.4 算法分析"></a>6.4 算法分析</h4><p><strong>最佳情况：O(nlog n)  最差情况：O(nlog n)  平均情况： O(nlog n)    空间复杂度：O(n)</strong></p>
<h3 id="7-快速排序（Quick-Sort）"><a href="#7-快速排序（Quick-Sort）" class="headerlink" title="7.快速排序（Quick Sort）"></a>7.快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录<strong>继续进行快速排序</strong>，以达到整个序列有序。</p>
<h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><p>快速排序使用<strong>分治法</strong>来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong>）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><pre><code>　　/**
     * 快速排序方法（左右指针法）
     * 从左至右依次选择元素作为基准，比较之后的元素
     * 将小于基准的元素一起放到基准左边（无须排序），
     * @param array
     * @param start
     * @param end
     * @return
     */
    public static int[] QuickSort(int[] array, int start, int end) {
        if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) {
            return null;
        }
        int smallIndex = partition(array, start, end);
        if (smallIndex &gt; start)
            QuickSort(array, start, smallIndex - 1);
        if (smallIndex &lt; end)
            QuickSort(array, smallIndex + 1, end);
        return array;
    }
    /**
     * 快速排序算法——partition
     * @param array
     * @param start
     * @param end
     * @return
     */
    public static int partition(int[] array, int start, int end) {
        int pivot = (int) (start + Math.random() * (end - start + 1));
        int smallIndex = start - 1;
        swap(array, pivot, end);
        for (int i = start; i &lt;= end; i++)
            if (array[i] &lt;= array[end]) {
                smallIndex++;
                if (i &gt; smallIndex)
                    swap(array, i, smallIndex);
            }
        return smallIndex;
    }

    /**
     * 交换数组内两个元素
     * @param array
     * @param i
     * @param j
     */
    public static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }</code></pre><h4 id="7-4-算法分析"><a href="#7-4-算法分析" class="headerlink" title="7.4 算法分析"></a>7.4 算法分析</h4><p><strong>最佳情况： O(nlog n)   最差情况： O(n^2)   平均情况： O(nlog n)　空间复杂度：O(1)</strong></p>
<h3 id="8-堆排序（Heap-Sort）"><a href="#8-堆排序（Heap-Sort）" class="headerlink" title="8.堆排序（Heap Sort）"></a>8.堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul>
<li>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区；（<strong>一般升序采用大顶堆，降序采用小顶堆</strong>）；</li>
<li>将堆顶元素 R[1]与最后一个元素 R[n]交换，此时得到新的无序区 (R1,R2,……Rn-1) 和新的有序区(Rn，), 且满足 R[1,2…n-1]&lt;=R[n]；</li>
<li>恢复堆。由于交换后新的堆顶 R[1]可能违反堆的性质，因此需要对当前无序区 (R1,R2,……Rn-1) 调整为新堆，然后再次将 R[1]与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。</li>
</ul>
<h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><p>注意：这里用到了完全二叉树的部分性质：详情见<a href="http://www.cnblogs.com/guoyaohua/p/8595289.html" target="_blank" rel="noopener">《数据结构二叉树知识点总结》</a></p>
<pre><code>    /**
     * 堆排序
     * 构建大顶堆，交换堆顶元素与末尾元素，恢复大顶堆
     * 每次将最大值“沉”到数组末端，升序
     * @param arr
     */  
    public static void sort(int[] arr) {
        // 1.构建大顶堆
        // 从最后一个非叶子节点开始
        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {
            // 第一个非叶子节点i，从下至上、从左至右调整结构
            adjustHeap(arr, i, arr.length);
        }
        // 2.交换堆顶与末尾 + 调整堆结构
        // j就是末尾元素
        for (int j = arr.length-1; j &gt; 0; j--) {
            // swap方法，交换操作
            swap(arr, i, j);
            // adjustHeap方法，重新调整堆结构
            adjustHeap(arr, i, j);
        }
    }

    /**
     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）
     * @param arr
     * @param i
     * @param length
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        // 以i节点为父节点，先将值放到temp保存
        int temp = arr[i];
        // 从i节点的左子节点开始，找出最大值，放到父节点位置
        for (int k = i*2+1; k &lt; length; k = k*2+1) {
            // 如果左子节点小于右子节点，k指向右子节点
            if (k+1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) {
                k++;
            }
            // 如果子节点大于父节点，将子节点值赋给父节点，最终使i为最大值
            // 注意，这里k覆盖了i位置元素
            if (arr[k] &gt; temp) {
                arr[i] = arr[k];
                i = k;
            }else {
                break;
            }
        }
        // 此时才真正确定i的位置，将保存的值还给i
        arr[i] = temp;
    }

    /**
     * 交换元素
     * @param arr
     * @param a
     * @param b
     */
    public static void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }</code></pre><h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列。同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序。</p>
<p><strong>最佳情况： O(nlogn) 最差情况： O(nlogn) 平均情况： O(nlogn)    空间复杂度：O(1)</strong></p>
<h3 id="9-计数排序（Counting-Sort）"><a href="#9-计数排序（Counting-Sort）" class="headerlink" title="9.计数排序（Counting Sort）"></a>9.计数排序（Counting Sort）</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。</p>
<h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</li>
</ul>
<h4 id="9-2-动图演示"><a href="#9-2-动图演示" class="headerlink" title="9.2 动图演示"></a>9.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><pre><code>/**
     * 计数排序
     *
     * @param array
     * @return
     */
    public static int[] CountingSort(int[] array) {
        if (array.length == 0) return array;
        int bias, min = array[0], max = array[0];
        for (int i = 1; i &lt; array.length; i++) {
            if (array[i] &gt; max)
                max = array[i];
            if (array[i] &lt; min)
                min = array[i];
        }
        bias = 0 - min;
        int[] bucket = new int[max - min + 1];
        Arrays.fill(bucket, 0);
        for (int i = 0; i &lt; array.length; i++) {
            bucket[array[i] + bias]++;
        }
        int index = 0, i = 0;
        while (index &lt; array.length) {
            if (bucket[i] != 0) {
                array[index] = i - bias;
                bucket[i]--;
                index++;
            } else
                i++;
        }
        return array;
    }</code></pre><h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<p><strong>最佳情况： O(n+k)  最差情况： O(n+k)  平均情况： O(n+k)</strong></p>
<h3 id="10-桶排序（Bucket-Sort）"><a href="#10-桶排序（Bucket-Sort）" class="headerlink" title="10.桶排序（Bucket Sort）"></a>10.桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>桶排序 (Bucket sort) 的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
<h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul>
<li>人为设置一个 BucketSize，作为每个桶所能放置多少个不同数值（例如当 BucketSize==5 时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放 100 个 3）；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。 </li>
</ul>
<p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为 1 时要手动减小 BucketSize 增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p>
<h4 id="10-2-图片演示"><a href="#10-2-图片演示" class="headerlink" title="10.2 图片演示"></a>10.2 图片演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><pre><code>    /**
     * 桶排序
     * 
     * @param array
     * @param bucketSize
     * @return
     */
    public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) {
        if (array == null || array.size() &lt; 2)
            return array;
        int max = array.get(0), min = array.get(0);
        // 找到最大值最小值
        for (int i = 0; i &lt; array.size(); i++) {
            if (array.get(i) &gt; max)
                max = array.get(i);
            if (array.get(i) &lt; min)
                min = array.get(i);
        }
        int bucketCount = (max - min) / bucketSize + 1;
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);
        ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; bucketCount; i++) {
            bucketArr.add(new ArrayList&lt;Integer&gt;());
        }
        for (int i = 0; i &lt; array.size(); i++) {
            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));
        }
        for (int i = 0; i &lt; bucketCount; i++) {
            if (bucketSize == 1) { // 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误
                for (int j = 0; j &lt; bucketArr.get(i).size(); j++)
                    resultArr.add(bucketArr.get(i).get(j));
            } else {
                if (bucketCount == 1)
                    bucketSize--;
                ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);
                for (int j = 0; j &lt; temp.size(); j++)
                    resultArr.add(temp.get(j));
            }
        }
        return resultArr;
    }</code></pre><h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p>
<p>*<em>最佳情况： O(n+k)   最差情况： O(n+k)   平均情况： O(n^2)　　*</em></p>
<h3 id="11-基数排序（Radix-Sort）"><a href="#11-基数排序（Radix-Sort）" class="headerlink" title="11.基数排序（Radix Sort）"></a>11.基数排序（Radix Sort）</h3><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<p><strong><em>MSD（Most significant digital）</em></strong>  从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<strong>MSD方式适用于位数多的序列</strong>。</p>
<p><strong><em>LSD（Least significant digital）</em></strong> 从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<strong>LSD方式适用于位数少的序列</strong>。</p>
<p>基数排序基于分别排序，分别收集，不改变相同元素之间的相对顺序，所以是稳定的。</p>
<p>下面以LSD为例。</p>
<h4 id="11-1-算法描述"><a href="#11-1-算法描述" class="headerlink" title="11.1 算法描述"></a>11.1 算法描述</h4><ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr 为原始数组，从最低位开始取每个位组成 radix 数组；</li>
<li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h4 id="11-2-动图演示"><a href="#11-2-动图演示" class="headerlink" title="11.2 动图演示"></a>11.2 动图演示</h4><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""> </p>
<h4 id="11-3-代码实现"><a href="#11-3-代码实现" class="headerlink" title="11.3 代码实现"></a>11.3 代码实现</h4><pre><code>　　/**
     * 基数排序
     * @param array
     * @return
     */
    public static int[] RadixSort(int[] array) {
        if (array == null || array.length &lt; 2) {
            return array;            
        }
        // 1.先算出最大数的位数；
        int max = array[0];
        for (int i = 1; i &lt; array.length; i++) {
            if (a[i] &gt; max) {
                max = a[i];
            }
        }
        int maxDigit = 0;
        while (max != 0) {
            max /= 10;
            maxDigit++;
        }
        int[][] buckets = new int[10][a.length];
        int base = 10;

        //从低位到高位，对每一位遍历，将所有元素分配到桶中
        for (int i = 0; i &lt; maxDigit; i++) {
            //存储各个桶中存储元素的数量
            int[] bucketLen = new int[10];  

            //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞
            for (int j = 0; j &lt; a.length; j++) {
                int whichBucket = (a[j] % base) / (base / 10);
                buckets[whichBucket][bucketLen[whichBucket]] = a[j];
                bucketLen[whichBucket]++;
            }

            int k = 0;
            //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞
            for (int l = 0; l &lt; buckets.length; l++) {
                for (int m =0; m &lt; bucketLen[l]; m++) {
                    a[k++] = buckets[l][m];
                }
            }
            System.out.println(&quot;Sorting: &quot; + Arrays.toString(a));
            base *= 10;
        }
        return array;
    }</code></pre><h4 id="11-4-算法分析"><a href="#11-4-算法分析" class="headerlink" title="11.4 算法分析"></a>11.4 算法分析</h4><p><strong>最佳情况：O(d<em>(n+r))   最差情况：O(d</em>(n+r))   平均情况：O(d*(n+r))    空间复杂度: O(n+r)</strong></p>
<p>其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p>
<p>基数排序更适合用于对时间, 字符串等这些整体权值未知的数据进行排序，适用于。</p>
<p>(1)数据范围较小，建议在小于1000</p>
<p>(2)每个数值都要大于等于0</p>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://juejin.im/post/5b95da8a5188255c775d8124" target="_blank" rel="noopener">https://juejin.im/post/5b95da8a5188255c775d8124</a></p>
<p><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></p>
<p><a href="https://www.cnblogs.com/Young111/p/11300929.html" target="_blank" rel="noopener">https://www.cnblogs.com/Young111/p/11300929.html</a></p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://topone233.github.io/2020/07/21/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(Java)/>https://topone233.github.io/2020/07/21/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(Java)/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-09-14T20:30:39+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Sep 14, 2020</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Java</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>数据结构</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>排序算法</p></a></div>


        
      
        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2020/07/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%8C30%20%E5%BC%A0%E5%9B%BE%E4%B8%80%E5%A5%97%E5%B8%A6%E8%B5%B0/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>进程和线程基础知识全家桶，30 张图一套带走</p>
          <p class='content'>
原文地址 

前言
先来看看一则小故事

我们写好的一行行代码，为了让其工作起来，我们还得把它送进城（进程）里，那既然进了城里，那肯定不能胡作非为了。
城里人有城里人的规矩，城中有个专门管辖你...</p>
        </a>
      
      
        <a class='next' href='/2020/07/20/%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/'>
          <p class='title'>反射、注解和动态代理<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>
原文地址 

一、Java 反射机制及基本用法反射是指计算机程序在运行时访问、检测和修改它本身状态或行为的一种能力，是一种元编程语言特性，有很多语言都提供了对反射机制的支持，它使程序能够编写程...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-排序算法说明"><span class="toc-text">1.排序算法说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-排序的定义"><span class="toc-text">1.1 排序的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-术语说明"><span class="toc-text">1.2 术语说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-算法总结"><span class="toc-text">1.3 算法总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-算法分类"><span class="toc-text">1.4 算法分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-比较和非比较的区别"><span class="toc-text">1.5 比较和非比较的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-冒泡排序（Bubble-Sort）"><span class="toc-text">2.冒泡排序（Bubble Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-算法描述"><span class="toc-text">2.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-动图演示"><span class="toc-text">2.2 动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-代码实现"><span class="toc-text">2.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-算法分析"><span class="toc-text">2.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-选择排序（Selection-Sort）"><span class="toc-text">3.选择排序（Selection Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-算法描述"><span class="toc-text">3.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-动图演示"><span class="toc-text">3.2 动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-代码实现"><span class="toc-text">3.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-算法分析"><span class="toc-text">3.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-插入排序（Insertion-Sort）"><span class="toc-text">4.插入排序（Insertion Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-算法描述"><span class="toc-text">4.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-动图演示"><span class="toc-text">4.2 动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-代码实现"><span class="toc-text">4.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-算法分析"><span class="toc-text">4.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-希尔排序（Shell-Sort）"><span class="toc-text">5.希尔排序（Shell Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-算法描述"><span class="toc-text">5.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-过程演示"><span class="toc-text">5.2 过程演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-代码实现"><span class="toc-text">5.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-算法分析"><span class="toc-text">5.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-归并排序（Merge-Sort）"><span class="toc-text">6.归并排序（Merge Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-算法描述"><span class="toc-text">6.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-动图演示"><span class="toc-text">6.2 动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-代码实现"><span class="toc-text">6.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-算法分析"><span class="toc-text">6.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-快速排序（Quick-Sort）"><span class="toc-text">7.快速排序（Quick Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-算法描述"><span class="toc-text">7.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-动图演示"><span class="toc-text">7.2 动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-代码实现"><span class="toc-text">7.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-算法分析"><span class="toc-text">7.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-堆排序（Heap-Sort）"><span class="toc-text">8.堆排序（Heap Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-算法描述"><span class="toc-text">8.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-动图演示"><span class="toc-text">8.2 动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-代码实现"><span class="toc-text">8.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-算法分析"><span class="toc-text">8.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-计数排序（Counting-Sort）"><span class="toc-text">9.计数排序（Counting Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-算法描述"><span class="toc-text">9.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-动图演示"><span class="toc-text">9.2 动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-代码实现"><span class="toc-text">9.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-算法分析"><span class="toc-text">9.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-桶排序（Bucket-Sort）"><span class="toc-text">10.桶排序（Bucket Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-算法描述"><span class="toc-text">10.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-图片演示"><span class="toc-text">10.2 图片演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-代码实现"><span class="toc-text">10.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-算法分析"><span class="toc-text">10.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-基数排序（Radix-Sort）"><span class="toc-text">11.基数排序（Radix Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-算法描述"><span class="toc-text">11.1 算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-动图演示"><span class="toc-text">11.2 动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-代码实现"><span class="toc-text">11.3 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-算法分析"><span class="toc-text">11.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料："><span class="toc-text">参考资料：</span></a></li></ol>
    </div>
  </section>


  


</aside>



      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © QSX1C</a></p>

        </div>
      
    
  </footer>


      <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  










  
  
<script src="/js/valine.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = $.trim($('#pjax-comment-placeholder').text()) || "快来评论吧~";

    let path = $.trim($('#pjax-comment-path').text());
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>







  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  


<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );
(function ($) {
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
})(jQuery);

</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://topone233.github.io' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://topone233.github.io' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://topone233.github.io' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>



<!-- more -->


    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
